{"version":3,"file":"background.bundle.js","mappings":"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","sources":["webpack://ai-content-assistant/./src/api/api-base.js","webpack://ai-content-assistant/./src/api/api-factory.js","webpack://ai-content-assistant/./src/api/api-interface.js","webpack://ai-content-assistant/./src/api/implementations/chatgpt-api.js","webpack://ai-content-assistant/./src/api/implementations/claude-api.js","webpack://ai-content-assistant/./src/api/implementations/deepseek-api.js","webpack://ai-content-assistant/./src/api/implementations/gemini-api.js","webpack://ai-content-assistant/./src/api/implementations/grok-api.js","webpack://ai-content-assistant/./src/api/implementations/mistral-api.js","webpack://ai-content-assistant/./src/background/api/api-coordinator.js","webpack://ai-content-assistant/./src/background/core/message-router.js","webpack://ai-content-assistant/./src/background/core/state-manager.js","webpack://ai-content-assistant/./src/background/initialization.js","webpack://ai-content-assistant/./src/background/listeners/tab-listener.js","webpack://ai-content-assistant/./src/background/listeners/tab-state-listener.js","webpack://ai-content-assistant/./src/background/services/content-extraction.js","webpack://ai-content-assistant/./src/background/services/content-processing.js","webpack://ai-content-assistant/./src/background/services/credential-manager.js","webpack://ai-content-assistant/./src/background/services/platform-integration.js","webpack://ai-content-assistant/./src/background/services/sidebar-manager.js","webpack://ai-content-assistant/./src/background/services/theme-service.js","webpack://ai-content-assistant/./src/services/ApiServiceManager.js","webpack://ai-content-assistant/./src/services/ConfigService.js","webpack://ai-content-assistant/./src/services/ContentFormatter.js","webpack://ai-content-assistant/./src/services/CredentialManager.js","webpack://ai-content-assistant/./src/services/ModelParameterService.js","webpack://ai-content-assistant/./src/services/SidebarStateManager.js","webpack://ai-content-assistant/./src/shared/constants.js","webpack://ai-content-assistant/./src/shared/logger.js","webpack://ai-content-assistant/./src/shared/utils/content-utils.js","webpack://ai-content-assistant/./src/shared/utils/error-utils.js","webpack://ai-content-assistant/webpack/bootstrap","webpack://ai-content-assistant/webpack/runtime/compat get default export","webpack://ai-content-assistant/webpack/runtime/define property getters","webpack://ai-content-assistant/webpack/runtime/hasOwnProperty shorthand","webpack://ai-content-assistant/webpack/runtime/make namespace object","webpack://ai-content-assistant/./src/background/index.js"],"sourcesContent":["// src/api/api-base.js\nconst ApiInterface = require('./api-interface');\nconst { extractApiErrorMessage } = require('../shared/utils/error-utils');\nconst ConfigService = require('../services/ConfigService');\nconst logger = require('../shared/logger').api;\n\n/**\n * Base class with shared API functionality\n */\nclass BaseApiService extends ApiInterface {\n  constructor(platformId) {\n    super();\n    this.platformId = platformId;\n    // Assign the shared logger directly\n    this.logger = logger;\n    this.credentials = null;\n    this.config = null;\n  }\n\n  async initialize(credentials) {\n    this.credentials = credentials;\n    this.config = await ConfigService.getPlatformApiConfig(this.platformId);\n    // Update log call to include platformId\n    this.logger.info(`[${this.platformId}] API service initialized`);\n  }\n\n  async processRequest(requestConfig) {\n    const { prompt, resolvedParams, formattedContent, onChunk, abortSignal } = requestConfig;\n    const { apiKey } = this.credentials;\n    const model = resolvedParams?.model;\n\n    try {\n      if (!requestConfig || !resolvedParams || !prompt || !onChunk) {\n        throw new Error(`[${this.platformId}] Invalid requestConfig provided to BaseApiService.processRequest`);\n      }\n      if (!apiKey) {\n        throw new Error(`[${this.platformId}] API key not available in BaseApiService`);\n      }\n\n      const structuredPrompt = this._createStructuredPrompt(prompt, formattedContent);\n      // Update log call\n      this.logger.info(`[${this.platformId}] Processing request for model ${model} with${formattedContent ? ' included' : 'out'} content.`);\n      const fetchOptions = await this._buildApiRequest(structuredPrompt, resolvedParams, apiKey);\n      await this._executeStreamingRequest(fetchOptions, onChunk, abortSignal, model);\n\n      // Update log call\n      this.logger.info(`[${this.platformId}] Streaming request for model ${model} completed.`);\n      return { success: true, model: model };\n\n    } catch (error) {\n      // Update log call\n      this.logger.error(`[${this.platformId}] Error in BaseApiService.processRequest for model ${model}:`, error);\n      if (onChunk && typeof onChunk === 'function') {\n        onChunk({\n          done: true,\n          error: `API Request Setup Error: ${error.message}`,\n          model: model || 'unknown'\n        });\n      }\n      return {\n        success: false,\n        error: `API Request Setup Error: ${error.message}`,\n        model: model || 'unknown'\n      };\n    }\n  }\n\n  _createStructuredPrompt(prompt, formattedContent) {\n    if (typeof formattedContent === 'string' && formattedContent.trim().length > 0) {\n      return `# INSTRUCTION\\n${prompt}\\n# EXTRACTED CONTENT\\n${formattedContent}`;\n    } else {\n      return prompt;\n    }\n  }\n\n  async validateCredentials() {\n    try {\n      const { apiKey } = this.credentials;\n      if (!apiKey) {\n        this.logger.warn(`[${this.platformId}] No API key provided for validation`);\n        return false;\n      }\n      const isValid = await this._validateApiKey(apiKey);\n      return isValid;\n    } catch (error) {\n      this.logger.error(`[${this.platformId}] Error validating credentials:`, error);\n      return false;\n    }\n  }\n\n  async _validateApiKey(apiKey) {\n    try {\n      const defaultModel = this.config?.defaultModel;\n      if (!defaultModel) {\n        this.logger.warn(`[${this.platformId}] No default model found in configuration`);\n        return false;\n      }\n      return await this._validateWithModel(apiKey, defaultModel);\n    } catch (error) {\n      this.logger.error(`[${this.platformId}] Error validating API key:`, error);\n      return false;\n    }\n  }\n\n  async _validateWithModel(apiKey, model) {\n    try {\n      this.logger.info(`[${this.platformId}] Attempting API key validation for model ${model}...`);\n      const fetchOptions = await this._buildValidationRequest(apiKey, model);\n      const response = await fetch(fetchOptions.url, {\n        method: fetchOptions.method,\n        headers: fetchOptions.headers,\n        body: fetchOptions.body,\n      });\n\n      if (response.ok) {\n        this.logger.info(`[${this.platformId}] API key validation successful for model ${model} (Status: ${response.status})`);\n        return true;\n      } else {\n        const errorMessage = await extractApiErrorMessage(response);\n        this.logger.warn(`[${this.platformId}] API key validation failed for model ${model} (Status: ${response.status}): ${errorMessage}`);\n        return false;\n      }\n    } catch (error) {\n      this.logger.error(`[${this.platformId}] API key validation error for model ${model}:`, error);\n      return false;\n    }\n  }\n\n  async _buildValidationRequest(apiKey, model) {\n    throw new Error('_buildValidationRequest must be implemented by subclasses');\n  }\n\n  async _buildApiRequest(prompt, params, apiKey) {\n    throw new Error('_buildApiRequest must be implemented by subclasses');\n  }\n\n  _parseStreamChunk(line) {\n    throw new Error('_parseStreamChunk must be implemented by subclasses');\n  }\n\n  _resetStreamState() {\n    // Base implementation does nothing. Subclasses can override.\n  }\n\n  /**\n   * Processes a parsed result from _parseStreamChunk, handling single or multiple chunks.\n   * @param {Object} parsedResult - The result from _parseStreamChunk.\n   * @param {Function} onChunk - The callback to send data to.\n   * @param {string} model - The model being used.\n   * @param {string} accumulatedContent - The current accumulated content string (will be updated).\n   * @returns {string} The updated accumulatedContent.\n   * @private\n   */\n  _handleParsedChunk(parsedResult, onChunk, model, accumulatedContent) {\n    if (parsedResult.type === 'content') {\n      if (Array.isArray(parsedResult.chunks)) {\n        for (const subChunk of parsedResult.chunks) {\n          if (subChunk && subChunk.length > 0) {\n            accumulatedContent += subChunk;\n            onChunk({ chunk: subChunk, done: false, model });\n          }\n        }\n      } else if (parsedResult.chunk) {\n        // Handle single chunk (standard case for other APIs)\n        accumulatedContent += parsedResult.chunk;\n        onChunk({ chunk: parsedResult.chunk, done: false, model });\n      }\n    }\n    return accumulatedContent;\n  }\n\n\n  async _executeStreamingRequest(fetchOptions, onChunk, abortSignal, model) {\n    let reader;\n    let accumulatedContent = \"\";\n    const decoder = new TextDecoder(\"utf-8\");\n    let buffer = \"\"; // Buffer for non-Gemini platforms\n\n    if (typeof this._resetStreamState === 'function') {\n      // Update log call\n      this.logger.info(`[${this.platformId}] Resetting stream state`);\n      this._resetStreamState();\n    }\n\n    try {\n      // Update log call\n      this.logger.info(`[${this.platformId}] Executing streaming request to ${fetchOptions.url} for model ${model}`);\n      const response = await fetch(fetchOptions.url, {\n        method: fetchOptions.method,\n        headers: fetchOptions.headers,\n        body: fetchOptions.body,\n        signal: abortSignal\n      });\n\n      if (!response.ok) {\n        const errorMessage = await extractApiErrorMessage(response);\n        // Update log call\n        this.logger.error(`[${this.platformId}] API Error (${response.status}) for model ${model}: ${errorMessage}`, response);\n        onChunk({ done: true, error: errorMessage, model });\n        throw new Error(`API request failed with status ${response.status}: ${errorMessage}`);\n      }\n      if (!response.body) throw new Error('Response body is null or undefined.');\n\n      reader = response.body.getReader();\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          // Update log call\n          this.logger.info(`[${this.platformId}] Stream finished naturally for model ${model}.`);\n          // Final buffer processing for all platforms\n          if (buffer.trim()) {\n            // Update log call\n            this.logger.warn(`[${this.platformId}] Processing remaining buffer content after stream end for model ${model}: \"${buffer}\"`);\n            try {\n              const parsedResult = this._parseStreamChunk(buffer.trim());\n              accumulatedContent = this._handleParsedChunk(parsedResult, onChunk, model, accumulatedContent);\n              if (parsedResult.type === 'error') {\n                onChunk({ done: true, error: parsedResult.error, model });\n                return false;\n              }\n            } catch (parseError) {\n              // Update log call\n              this.logger.error(`[${this.platformId}] Error parsing final buffer chunk for model ${model}:`, parseError, 'Buffer:', buffer);\n              onChunk({ done: true, error: `Error parsing final stream data: ${parseError.message}`, model });\n              return false;\n            }\n          }\n          onChunk({ chunk: '', done: true, model, fullContent: accumulatedContent });\n          break; // Exit the loop\n        }\n\n        const decodedChunk = decoder.decode(value, { stream: true });\n\n        // Standard SSE handling for all platforms\n        buffer += decodedChunk;\n        let lineEnd;\n        while ((lineEnd = buffer.indexOf('\\n')) !== -1) {\n          const line = buffer.substring(0, lineEnd).trim();\n          buffer = buffer.substring(lineEnd + 1);\n          if (!line) continue;\n\n          try {\n            const parsedResult = this._parseStreamChunk(line);\n            accumulatedContent = this._handleParsedChunk(parsedResult, onChunk, model, accumulatedContent);\n\n            if (parsedResult.type === 'error') {\n              // Update log call\n              this.logger.error(`[${this.platformId}] Parsed stream error for model ${model}: ${parsedResult.error}`);\n              onChunk({ done: true, error: parsedResult.error, model });\n              return false; // Stop processing loop\n            }\n            // Ignore 'done' and 'ignore' types here\n          } catch (parseError) {\n            // Update log call\n            this.logger.error(`[${this.platformId}] Error parsing stream chunk for model ${model}:`, parseError, 'Line:', line);\n            onChunk({ done: true, error: `Error parsing stream data: ${parseError.message}`, model });\n            return false; // Stop processing loop\n          }\n        }\n\n      }\n\n      return true; // Signal successful completion\n\n    } catch (error) {\n      // Handle AbortError specifically\n      if (error.name === 'AbortError') {\n        this.logger.info(`[${this.platformId}] API request cancelled by user (AbortError) for model ${model}.`);\n        // Send a specific 'Cancelled by user' message via onChunk\n        onChunk({ done: true, error: 'Cancelled by user', model });\n        // No need to re-throw AbortError, it's handled.\n      } else {\n        // Handle other errors during fetch or reading\n        this.logger.error(`[${this.platformId}] Unhandled streaming error for model ${model}:`, error);\n        onChunk({ done: true, error: error.message || 'An unknown streaming error occurred', model });\n        // Re-throw other errors to be caught by the outer try/catch in processRequest\n        throw error;\n      }\n      return false; // Indicate handled error (AbortError) or that an error occurred\n    } finally {\n      // Cleanup: Attempt to cancel the reader if it exists.\n      if (reader) {\n        try {\n          // Attempt to cancel the reader. This also releases the lock.\n          await reader.cancel();\n          this.logger.info(`[${this.platformId}] Stream reader cancelled successfully for model ${model}.`);\n        } catch (cancelError) {\n          this.logger.warn(`[${this.platformId}] Error cancelling stream reader for model ${model} (potentially expected after abort):`, cancelError);\n        }\n        // No need for releaseLock() as cancel() handles it.\n      } else {\n        // Update log call\n        this.logger.info(`[${this.platformId}] No active reader found in finally block for model ${model}.`);\n      }\n    }\n  }\n}\n\nmodule.exports = BaseApiService;","// src/api/api-factory.js\n\nconst BaseApiService = require('./api-base');\nconst ChatGptApiService = require('./implementations/chatgpt-api');\nconst ClaudeApiService = require('./implementations/claude-api');\nconst GeminiApiService = require('./implementations/gemini-api');\nconst MistralApiService = require('./implementations/mistral-api');\nconst DeepSeekApiService = require('./implementations/deepseek-api');\nconst GrokApiService = require('./implementations/grok-api');\n\n/**\n * Factory class for creating API service instances\n */\nclass ApiFactory {\n  /**\n   * Create an API service instance for the specified platform\n   * @param {string} platformId - Platform identifier (e.g., 'chatgpt', 'claude')\n   * @returns {BaseApiService} API service instance\n   * @throws {Error} If platform is not supported\n   */\n  static createApiService(platformId) {\n    switch (platformId.toLowerCase()) {\n      case 'chatgpt':\n        return new ChatGptApiService();\n      case 'claude':\n        return new ClaudeApiService();\n      case 'gemini':\n        return new GeminiApiService();\n      case 'mistral':\n        return new MistralApiService();\n      case 'deepseek':\n        return new DeepSeekApiService();\n      case 'grok':\n        return new GrokApiService();\n      default:\n        throw new Error(`Unsupported API platform: ${platformId}`);\n    }\n  }\n}\n\nmodule.exports = ApiFactory;","/**\n * Interface defining contract for all API implementations\n */\nclass ApiInterface {\n  /**\n   * Initialize the API client with credentials\n   * @param {Object} credentials - API credentials\n   * @returns {Promise<void>}\n   */\n  async initialize(credentials) {\n    throw new Error('initialize must be implemented by subclasses');\n  }\n  \n  /**\n   * Process unified API request with complete configuration\n   * @param {Object} requestConfig - Unified request configuration\n   * @param {Object} requestConfig.contentData - Extracted content data\n   * @param {string} requestConfig.prompt - Formatted prompt\n   * @param {string} [requestConfig.model] - Optional model override\n   * @param {Array} [requestConfig.conversationHistory] - Optional conversation history\n   * @param {boolean} [requestConfig.streaming] - Whether to use streaming mode\n   * @param {Function} [requestConfig.onChunk] - Callback for streaming chunks\n   * @param {number} [requestConfig.tabId] - Tab ID for token accounting\n   * @returns {Promise<Object>} Standardized response object\n   */\n  async processRequest(requestConfig) {\n    throw new Error('processRequest must be implemented by subclasses');\n  }\n  \n  /**\n   * Lightweight method to verify API credentials\n   * @returns {Promise<boolean>} Validation result\n   */\n  async validateCredentials() {\n    throw new Error('validateCredentials must be implemented by subclasses');\n  }\n}\n\nmodule.exports = ApiInterface;\n","const BaseApiService = require('../api-base');\n\n/**\n * ChatGPT API implementation\n */\nclass ChatGptApiService extends BaseApiService {\n  constructor() {\n    super('chatgpt');\n  }\n\n  /**\n   * Build the platform-specific API request options for ChatGPT.\n   * @override\n   * @protected\n   * @param {string} prompt - The final structured prompt.\n   * @param {Object} params - Resolved model parameters (model, temp, history, etc.).\n   * @param {string} apiKey - The API key.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildApiRequest(prompt, params, apiKey) {\n    const endpoint = this.config?.endpoint || 'https://api.openai.com/v1/chat/completions';\n    this.logger.info(`[${this.platformId}] Building API request for model: ${params.model}`);\n\n    const requestPayload = {\n      model: params.model,\n      stream: true\n    };\n\n    const messages = [];\n    if (params.systemPrompt) {\n      messages.push({ role: 'system', content: params.systemPrompt });\n    }\n    if (params.conversationHistory && params.conversationHistory.length > 0) {\n      messages.push(...this._formatOpenAIMessages(params.conversationHistory));\n    }\n    messages.push({ role: 'user', content: prompt }); // Use the structured prompt\n    requestPayload.messages = messages;\n\n    // Apply model parameters\n    if (params.parameterStyle === 'reasoning') {\n      requestPayload[params.tokenParameter || 'max_completion_tokens'] = params.maxTokens;\n    } else {\n      requestPayload[params.tokenParameter || 'max_tokens'] = params.maxTokens;\n      if ('temperature' in params) {\n        requestPayload.temperature = params.temperature;\n      }\n      if ('topP' in params) {\n        requestPayload.top_p = params.topP;\n      }\n    }\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(requestPayload)\n    };\n  }\n\n  /**\n   * Parse a single line/chunk from the ChatGPT API stream.\n   * @override\n   * @protected\n   * @param {string} line - A single line string from the stream.\n   * @returns {Object} Parsed result: { type: 'content' | 'done' | 'ignore', chunk?: string }.\n   */\n  _parseStreamChunk(line) {\n    if (!line) {\n      return { type: 'ignore' };\n    }\n\n    // OpenAI uses 'data: [DONE]' to signal the end of the stream content\n    if (line === 'data: [DONE]') {\n      return { type: 'done' }; // Signal done, but let the reader confirm stream end\n    }\n\n    if (line.startsWith('data: ')) {\n      try {\n        const data = JSON.parse(line.substring(6));\n        const content = data.choices?.[0]?.delta?.content;\n\n        if (content) {\n          return { type: 'content', chunk: content };\n        } else {\n          // Ignore chunks without content (e.g., role markers, finish_reason)\n          return { type: 'ignore' };\n        }\n      } catch (e) {\n        this.logger.error(`[${this.platformId}] Error parsing stream chunk:`, e, 'Line:', line);\n        // Treat parsing errors as stream errors - return error type\n        return { type: 'error', error: `Error parsing stream data: ${e.message}` };\n      }\n    }\n\n    // Ignore lines that don't start with 'data: ' (e.g., potential comments or empty lines already handled)\n    return { type: 'ignore' };\n  }\n\n  /**\n   * Format conversation history for OpenAI API\n   * @param {Array} history - Conversation history array\n   * @returns {Array} Formatted messages for OpenAI API\n   */\n  _formatOpenAIMessages(history) {\n    return history.map(msg => {\n      // Map internal role names to OpenAI roles\n      let role = 'user';\n      if (msg.role === 'assistant') role = 'assistant';\n      else if (msg.role === 'system') role = 'system';\n\n      return {\n        role,\n        content: msg.content\n      };\n    });\n  }\n\n  /**\n   * Build the platform-specific API request options for validation.\n   * @override\n   * @protected\n   * @param {string} apiKey - The API key to validate.\n   * @param {string} model - The model to use for validation.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildValidationRequest(apiKey, model) {\n    const endpoint = this.config?.endpoint || 'https://api.openai.com/v1/chat/completions';\n    const validationPayload = {\n      model: model,\n      messages: [\n        { role: 'user', content: 'API validation check' }\n      ],\n      max_tokens: 1 // Minimum tokens\n    };\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(validationPayload)\n    };\n  }\n}\n\nmodule.exports = ChatGptApiService;","const BaseApiService = require('../api-base');\n\n/**\n * Claude API implementation\n */\nclass ClaudeApiService extends BaseApiService {\n  constructor() {\n    super('claude');\n  }\n\n  /**\n   * Build the platform-specific API request options for Claude.\n   * @override\n   * @protected\n   * @param {string} prompt - The final structured prompt.\n   * @param {Object} params - Resolved model parameters (model, temp, history, etc.).\n   * @param {string} apiKey - The API key.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildApiRequest(prompt, params, apiKey) {\n    const endpoint = this.config?.endpoint || 'https://api.anthropic.com/v1/messages';\n    this.logger.info(`[${this.platformId}] Building API request for model: ${params.model}`);\n\n    const requestPayload = {\n      model: params.model,\n      max_tokens: params.maxTokens,\n      messages: [{ role: 'user', content: [{ type: \"text\", text: prompt }] }], // Start with current prompt\n      stream: true\n    };\n\n    // Apply optional parameters\n    if ('temperature' in params) {\n      requestPayload.temperature = params.temperature;\n    }\n    if ('topP' in params) {\n      requestPayload.top_p = params.topP;\n    }\n    if (params.systemPrompt) {\n      requestPayload.system = params.systemPrompt;\n    }\n\n    // Prepend conversation history if available\n    if (params.conversationHistory && params.conversationHistory.length > 0) {\n      // Use the helper to format history and add the current prompt correctly\n      requestPayload.messages = this._formatClaudeMessages(params.conversationHistory, prompt);\n    }\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01',\n        'anthropic-dangerous-direct-browser-access': 'true' // Required for direct browser calls\n      },\n      body: JSON.stringify(requestPayload)\n    };\n  }\n\n  /**\n   * Parse a single line/chunk from the Claude API stream.\n   * Handles Server-Sent Events (SSE) format used by Claude.\n   * @override\n   * @protected\n   * @param {string} line - A single line string from the stream.\n   * @returns {Object} Parsed result: { type: 'content' | 'error' | 'done' | 'ignore', chunk?: string, error?: string }.\n   */\n  _parseStreamChunk(line) {\n    if (!line) {\n      return { type: 'ignore' };\n    }\n\n    // Claude uses event types\n    if (line.startsWith('event: ')) {\n      const eventType = line.substring(7).trim();\n      // We only care about the data associated with specific events.\n      // 'message_stop' signals completion, but we let the reader handle the actual stream end.\n      // 'ping' can be ignored.\n      if (eventType === 'message_stop') {\n        return { type: 'done' }; // Signal potential end, base class waits for reader\n      }\n      // Other events like 'message_start', 'content_block_start/stop' are ignored for now.\n      return { type: 'ignore' };\n    }\n\n    if (line.startsWith('data: ')) {\n      try {\n        const data = JSON.parse(line.substring(6));\n\n        // Check for content delta\n        if (data.type === 'content_block_delta' && data.delta?.type === 'text_delta') {\n          const content = data.delta.text;\n          return content ? { type: 'content', chunk: content } : { type: 'ignore' };\n        }\n\n        // Check for errors reported within the stream\n        if (data.type === 'error') {\n          const streamErrorMessage = `Stream error: ${data.error?.type} - ${data.error?.message || 'Unknown stream error'}`;\n          this.logger.error(`[${this.platformId}] ${streamErrorMessage}`, data.error);\n          return { type: 'error', error: streamErrorMessage };\n        }\n\n        // Ignore other data types like 'message_delta' (stop_reason is handled by 'message_stop' event or reader end)\n        return { type: 'ignore' };\n\n      } catch (e) {\n        // Update log call\n        this.logger.error(`[${this.platformId}] Error parsing stream chunk:`, e, 'Line:', line);\n        return { type: 'error', error: `Error parsing stream data: ${e.message}` };\n      }\n    }\n\n    // Ignore lines that are not 'event:' or 'data:'\n    return { type: 'ignore' };\n  }\n\n  /**\n   * Format conversation history for Claude API\n   * @param {Array} history - Conversation history array\n   * @param {string} currentPrompt - Current user prompt\n   * @returns {Array} Formatted messages for Claude API\n   */\n  _formatClaudeMessages(history, currentPrompt) {\n    const formattedMessages = [];\n\n    // Process conversation history\n    for (const message of history) {\n      // Map internal role to Claude role\n      const role = message.role === 'assistant' ? 'assistant' : 'user';\n\n      formattedMessages.push({\n        role: role,\n        content: [\n          {\n            type: \"text\",\n            text: message.content\n          }\n        ]\n      });\n    }\n\n    // Add current prompt as the final user message\n    formattedMessages.push({\n      role: 'user',\n      content: [\n        {\n          type: \"text\",\n          text: currentPrompt\n        }\n      ]\n    });\n\n    return formattedMessages;\n  }\n\n  /**\n   * Build the platform-specific API request options for validation.\n   * @override\n   * @protected\n   * @param {string} apiKey - The API key to validate.\n   * @param {string} model - The model to use for validation.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildValidationRequest(apiKey, model) {\n    const endpoint = this.config?.endpoint || 'https://api.anthropic.com/v1/messages';\n    const validationPayload = {\n      model: model,\n      max_tokens: 1, // Minimum tokens needed\n      messages: [\n        {\n          role: 'user',\n          content: [\n            {\n              type: \"text\",\n              text: \"API validation check\"\n            }\n          ]\n        }\n      ]\n    };\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01',\n        'anthropic-dangerous-direct-browser-access': 'true' // Required for direct browser calls\n      },\n      body: JSON.stringify(validationPayload)\n    };\n  }\n}\n\nmodule.exports = ClaudeApiService;","const BaseApiService = require('../api-base');\n\n/**\n * DeepSeek API implementation\n */\nclass DeepSeekApiService extends BaseApiService {\n  constructor() {\n    super('deepseek');\n  }\n\n  /**\n   * Build the platform-specific API request options for DeepSeek.\n   * Handles merging consecutive user messages as required by the API.\n   * @override\n   * @protected\n   * @param {string} prompt - The final structured prompt (current user input).\n   * @param {Object} params - Resolved model parameters (model, temp, history, etc.).\n   * @param {string} apiKey - The API key.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildApiRequest(prompt, params, apiKey) {\n    const endpoint = this.config?.endpoint || 'https://api.deepseek.com/v1/chat/completions';\n    this.logger.info(`[${this.platformId}] Building API request for model: ${params.model}`);\n\n    const requestPayload = {\n      model: params.model,\n      stream: true\n    };\n\n    let messages = [];\n    // Add system prompt first if it exists\n    if (params.systemPrompt) {\n      messages.push({ role: 'system', content: params.systemPrompt });\n    }\n\n    // Format history, merging consecutive roles (excluding system)\n    if (params.conversationHistory && params.conversationHistory.length > 0) {\n      messages.push(...this._formatDeepSeekMessages(params.conversationHistory));\n    }\n\n    // Now, handle the current user prompt, merging if necessary\n    const lastMessage = messages.length > 0 ? messages[messages.length - 1] : null;\n\n    if (lastMessage && lastMessage.role === 'user') {\n      // Merge the current prompt into the last user message\n      this.logger.info(`[${this.platformId}] Merging current user prompt with previous user message for DeepSeek compatibility.`);\n      lastMessage.content += `\\n\\n${prompt}`; // Append the new prompt text\n    } else {\n      // Add the current prompt as a new user message\n      messages.push({ role: 'user', content: prompt });\n    }\n\n    // Assign the final message list to the payload\n    requestPayload.messages = messages;\n\n    // Apply other parameters\n    requestPayload[params.tokenParameter || 'max_tokens'] = params.maxTokens;\n    if ('temperature' in params) {\n      requestPayload.temperature = params.temperature;\n    }\n    if ('topP' in params) {\n      requestPayload.top_p = params.topP;\n    }\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(requestPayload)\n    };\n  }\n\n  /**\n   * Parse a single line/chunk from the DeepSeek API stream.\n   * Similar format to OpenAI.\n   * @override\n   * @protected\n   * @param {string} line - A single line string from the stream.\n   * @returns {Object} Parsed result: { type: 'content' | 'done' | 'ignore' | 'error', chunk?: string, error?: string }.\n   */\n  _parseStreamChunk(line) {\n    if (!line) {\n      return { type: 'ignore' };\n    }\n\n    // DeepSeek also uses 'data: [DONE]'\n    if (line === 'data: [DONE]') {\n      return { type: 'done' };\n    }\n\n    if (line.startsWith('data: ')) {\n      try {\n        const data = JSON.parse(line.substring(6));\n        const content = data.choices?.[0]?.delta?.content;\n\n        if (content) {\n          return { type: 'content', chunk: content };\n        } else {\n          // Ignore chunks without content (like finish_reason markers)\n          if (data.choices?.[0]?.finish_reason) {\n             this.logger.info(`[${this.platformId}] Stream finished with reason: ${data.choices[0].finish_reason}`);\n          }\n          return { type: 'ignore' };\n        }\n      } catch (e) {\n        this.logger.error(`[${this.platformId}] Error parsing stream chunk:`, e, 'Line:', line);\n        return { type: 'error', error: `Error parsing stream data: ${e.message}` };\n      }\n    }\n\n    return { type: 'ignore' };\n  }\n\n  /**\n   * Format conversation history for DeepSeek API, merging consecutive messages of the same role.\n   * Skips system messages or unknown roles found within the history.\n   * @param {Array} history - Conversation history array\n   * @returns {Array} Formatted messages for DeepSeek API\n   */\n  _formatDeepSeekMessages(history) {\n    const formattedMessages = [];\n    // Update log call\n    this.logger.info(`[${this.platformId}] Formatting ${history.length} history messages, merging consecutive roles.`);\n\n    for (const msg of history) {\n      let apiRole;\n      // Map internal roles to API roles, skipping system/unknown messages within history\n      if (msg.role === 'user') {\n        apiRole = 'user';\n      } else if (msg.role === 'assistant') {\n        apiRole = 'assistant';\n      } else {\n        this.logger.warn(`[${this.platformId}] Skipping message with role '${msg.role || 'unknown'}' found within conversation history for API call.`);\n        continue; // Skip system or unknown roles\n      }\n\n      const lastMessage = formattedMessages.length > 0 ? formattedMessages[formattedMessages.length - 1] : null;\n\n      // Check if the last message exists and has the same role as the current message\n      if (lastMessage && lastMessage.role === apiRole) {\n        // Merge content with the last message\n        this.logger.info(`[${this.platformId}] Merging consecutive '${apiRole}' message content for compatibility.`);\n        lastMessage.content += `\\n\\n${msg.content}`; // Append content\n      } else {\n        // Add as a new message if roles differ or it's the first message\n        formattedMessages.push({ role: apiRole, content: msg.content });\n      }\n    }\n\n    // Final check for alternation (optional, but good for debugging)\n    for (let i = 0; i < formattedMessages.length - 1; i++) {\n        if (formattedMessages[i].role === formattedMessages[i+1].role) {\n            // Update log call\n            this.logger.error(`[${this.platformId}] Formatting failed: Consecutive roles found after merge at index ${i}. Role: ${formattedMessages[i].role}`);\n            // Handle error case if needed, e.g., return only valid prefix\n        }\n    }\n\n    this.logger.info(`[${this.platformId}] Formatted history contains ${formattedMessages.length} messages after merging.`);\n    return formattedMessages;\n  }\n\n  /**\n   * Build the platform-specific API request options for validation.\n   * @override\n   * @protected\n   * @param {string} apiKey - The API key to validate.\n   * @param {string} model - The model to use for validation.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildValidationRequest(apiKey, model) {\n    const endpoint = this.config?.endpoint || 'https://api.deepseek.com/v1/chat/completions';\n    const validationPayload = {\n      model: model,\n      messages: [\n        { role: 'user', content: 'API validation check' }\n      ],\n      max_tokens: 1 // Minimum tokens needed\n    };\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(validationPayload)\n    };\n  }\n}\n\nmodule.exports = DeepSeekApiService;","// src/api/implementations/gemini-api.js\nconst BaseApiService = require('../api-base');\n\n/**\n * Gemini API implementation\n */\nclass GeminiApiService extends BaseApiService {\n  constructor() {\n    super('gemini');\n  }\n\n  _getGeminiEndpoint(model, method) {\n    const baseTemplate = \"https://generativelanguage.googleapis.com/{version}/models/{model}{method}\";\n    if (!model || !method) {\n      throw new Error(\"Model and method are required to build Gemini endpoint.\");\n    }\n    const isExperimental = model.includes('-exp-');\n    const apiVersion = isExperimental ? 'v1beta' : 'v1';\n    this.logger.info(`[${this.platformId}] Using API version '${apiVersion}' for model '${model}'`);\n    return baseTemplate\n      .replace('{version}', apiVersion)\n      .replace('{model}', model)\n      .replace('{method}', method);\n  }\n\n  async _buildApiRequest(prompt, params, apiKey) {\n    const endpoint = this._getGeminiEndpoint(params.model, ':streamGenerateContent');\n    this.logger.info(`[${this.platformId}] Building API request to: ${endpoint}`);\n    const url = new URL(endpoint);\n    url.searchParams.append('alt', 'sse');\n    url.searchParams.append('key', apiKey);\n\n    let formattedRequest;\n    if (params.conversationHistory && params.conversationHistory.length > 0) {\n      formattedRequest = this._formatGeminiRequestWithHistory(params.conversationHistory, prompt);\n    } else {\n      formattedRequest = { contents: [{ role: 'user', parts: [{ text: prompt }] }] };\n    }\n\n    if (params.systemPrompt) {\n      if (params.modelSupportsSystemPrompt === true) {\n        this.logger.info(`[${this.platformId}] Adding system prompt using systemInstruction for model: ${params.model}.`);\n        formattedRequest.systemInstruction = { parts: [{ text: params.systemPrompt }] };\n      } else {\n        this.logger.warn(`[${this.platformId}] System prompts via systemInstruction are not supported by the selected model: ${params.model}. The provided system prompt will be IGNORED.`);\n      }\n    }\n\n    formattedRequest.generationConfig = {};\n    if (params.tokenParameter) {\n      formattedRequest.generationConfig[params.tokenParameter] = params.maxTokens;\n    } else {\n      formattedRequest.generationConfig.maxOutputTokens = params.maxTokens;\n    }\n    if ('temperature' in params) {\n      formattedRequest.generationConfig.temperature = params.temperature;\n    }\n    if ('topP' in params) {\n      formattedRequest.generationConfig.topP = params.topP;\n    }\n\n    return {\n      url: url.toString(),\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(formattedRequest)\n    };\n  }\n\n  /**\n   * Parse a single line/chunk from the Gemini API stream.\n   * Handles potentially fragmented JSON objects/arrays within the stream.\n   * If a complete JSON structure is an array, iterates through its elements.\n   * Extracts the text from each part as an individual chunk.\n   * @override\n   * @protected\n   * @param {string} line - A single line string chunk received from the base class stream loop, OR an empty string to process the internal buffer.\n   * @returns {Object} Parsed result: { type: 'content', chunks: string[] } | { type: 'error', error: string } | { type: 'ignore' }.\n   *                   Returns 'ignore' if the buffer doesn't contain a complete JSON object yet.\n   */\n  _parseStreamChunk(line) {\n    if (!line || !line.startsWith('data: ')) {\n      // Ignore empty lines or lines not starting with 'data: '\n      // Also handles potential 'event:' lines if Gemini SSE uses them.\n      // Check for potential [DONE] signal if Gemini SSE uses it.\n      if (line === 'data: [DONE]') {\n         // Update log call\n         this.logger.info(`[${this.platformId}] SSE stream signal [DONE] received.`);\n         return { type: 'done' };\n      }\n      return { type: 'ignore' };\n    }\n\n    // Extract the JSON string part after 'data: '\n    const jsonString = line.substring(5).trim(); // Get content after 'data: '\n\n    if (!jsonString) {\n      return { type: 'ignore' }; // Ignore if data part is empty\n    }\n\n    try {\n      const data = JSON.parse(jsonString);\n\n      // Extract text content - assuming the same structure as the previous JSON stream\n      // Check candidates -> content -> parts -> text\n      const textChunk = data?.candidates?.[0]?.content?.parts?.[0]?.text;\n\n      if (textChunk && typeof textChunk === 'string') {\n        // Return the extracted text chunk\n        return { type: 'content', chunk: textChunk };\n      } else {\n        // If structure is valid but no text found, or if error field exists\n        if (data?.error) {\n            const errorMessage = data.error.message || JSON.stringify(data.error);\n            this.logger.error(`[${this.platformId}] SSE stream returned an error: ${errorMessage}`, data.error);\n            return { type: 'error', error: `API Error in stream: ${errorMessage}` };\n        }\n        // Log other valid structures without text for debugging\n        if (data?.candidates?.[0]?.finishReason) {\n            this.logger.info(`[${this.platformId}] SSE stream finished with reason: ${data.candidates[0].finishReason}`);\n            // We might treat specific finish reasons differently later if needed.\n            // For now, ignore finish reason markers unless they contain an error.\n        } else {\n            this.logger.warn(`[${this.platformId}] Parsed SSE data, but no text chunk found or structure mismatch.`, data);\n        }\n        return { type: 'ignore' }; // Ignore chunks without usable text content\n      }\n    } catch (parseError) {\n      this.logger.error(`[${this.platformId}] Error parsing SSE JSON chunk:`, parseError, 'Raw JSON String:', jsonString);\n      // Return error type on JSON parsing failure\n      return { type: 'error', error: `Error parsing stream data: ${parseError.message}` };\n    }\n  }\n\n  _formatGeminiRequestWithHistory(history, currentPrompt) {\n    const contents = [];\n    for (const message of history) {\n      const messageRole = message.role === 'assistant' ? 'model' : 'user';\n      contents.push({ role: messageRole, parts: [{ text: message.content }] });\n    }\n    contents.push({ role: 'user', parts: [{ text: currentPrompt }] });\n    return { contents };\n  }\n\n  async _buildValidationRequest(apiKey, model) {\n    const endpoint = this._getGeminiEndpoint(model, ':generateContent');\n    this.logger.info(`[${this.platformId}] Building validation request to: ${endpoint}`);\n    const url = new URL(endpoint);\n    url.searchParams.append('key', apiKey);\n    const validationPayload = {\n      contents: [{ role: 'user', parts: [{ text: \"API validation check\" }] }],\n      generationConfig: { maxOutputTokens: 1 }\n    };\n    return {\n      url: url.toString(),\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(validationPayload)\n    };\n  }\n}\n\nmodule.exports = GeminiApiService;","const BaseApiService = require('../api-base');\n\n/**\n * Grok API implementation\n */\nclass GrokApiService extends BaseApiService {\n  constructor() {\n    super('grok');\n  }\n\n  /**\n   * Build the platform-specific API request options for Grok.\n   * @override\n   * @protected\n   * @param {string} prompt - The final structured prompt.\n   * @param {Object} params - Resolved model parameters (model, temp, history, etc.).\n   * @param {string} apiKey - The API key.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildApiRequest(prompt, params, apiKey) {\n    const endpoint = this.config?.endpoint || 'https://api.x.ai/v1/chat/completions';\n    this.logger.info(`[${this.platformId}] Building API request for model: ${params.model}`);\n\n    const requestPayload = {\n      model: params.model,\n      stream: true\n    };\n\n    const messages = [];\n    if (params.systemPrompt) {\n      messages.push({ role: 'system', content: params.systemPrompt });\n    }\n    if (params.conversationHistory && params.conversationHistory.length > 0) {\n      messages.push(...this._formatGrokMessages(params.conversationHistory));\n    }\n    messages.push({ role: 'user', content: prompt }); // Use the structured prompt\n    requestPayload.messages = messages;\n\n    // Apply model parameters\n    requestPayload[params.tokenParameter || 'max_tokens'] = params.maxTokens;\n    if ('temperature' in params) {\n      requestPayload.temperature = params.temperature;\n    }\n    if ('topP' in params) {\n      requestPayload.top_p = params.topP;\n    }\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(requestPayload)\n    };\n  }\n\n  /**\n   * Parse a single line/chunk from the Grok API stream.\n   * Assumes OpenAI-compatible SSE format.\n   * @override\n   * @protected\n   * @param {string} line - A single line string from the stream.\n   * @returns {Object} Parsed result: { type: 'content' | 'done' | 'ignore' | 'error', chunk?: string, error?: string }.\n   */\n  _parseStreamChunk(line) {\n    if (!line) {\n      return { type: 'ignore' };\n    }\n\n    // Grok uses 'data: [DONE]' like OpenAI\n    if (line === 'data: [DONE]') {\n      return { type: 'done' };\n    }\n\n    if (line.startsWith('data: ')) {\n      try {\n        const data = JSON.parse(line.substring(6));\n        const content = data.choices?.[0]?.delta?.content;\n\n        if (content) {\n          return { type: 'content', chunk: content };\n        } else {\n          // Ignore chunks without content (like finish_reason markers)\n          if (data.choices?.[0]?.finish_reason) {\n             this.logger.info(`[${this.platformId}] Stream finished with reason: ${data.choices[0].finish_reason}`);\n          }\n          return { type: 'ignore' };\n        }\n      } catch (e) {\n        this.logger.error(`[${this.platformId}] Error parsing stream chunk:`, e, 'Line:', line);\n        return { type: 'error', error: `Error parsing stream data: ${e.message}` };\n      }\n    }\n\n    return { type: 'ignore' };\n  }\n\n  /**\n   * Format conversation history for Grok API\n   * @param {Array} history - Conversation history array\n   * @returns {Array} Formatted messages for Grok API\n   */\n  _formatGrokMessages(history) {\n    return history.map(msg => {\n      // Map internal role names to Grok roles (same as OpenAI format)\n      let role = 'user';\n      if (msg.role === 'assistant') role = 'assistant';\n      else if (msg.role === 'system') role = 'system';\n\n      return {\n        role,\n        content: msg.content\n      };\n    });\n  }\n\n  /**\n   * Build the platform-specific API request options for validation.\n   * @override\n   * @protected\n   * @param {string} apiKey - The API key to validate.\n   * @param {string} model - The model to use for validation.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildValidationRequest(apiKey, model) {\n    const endpoint = this.config?.endpoint || 'https://api.x.ai/v1/chat/completions';\n    const validationPayload = {\n      model: model,\n      messages: [\n        { role: 'user', content: 'API validation check' }\n      ],\n      max_tokens: 1 // Minimum tokens needed\n    };\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(validationPayload)\n    };\n  }\n}\n\nmodule.exports = GrokApiService;","const BaseApiService = require('../api-base');\n\n/**\n * Mistral API implementation\n */\nclass MistralApiService extends BaseApiService {\n  constructor() {\n    super('mistral');\n  }\n\n  /**\n   * Build the platform-specific API request options for Mistral.\n   * @override\n   * @protected\n   * @param {string} prompt - The final structured prompt.\n   * @param {Object} params - Resolved model parameters (model, temp, history, etc.).\n   * @param {string} apiKey - The API key.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildApiRequest(prompt, params, apiKey) {\n    const endpoint = this.config?.endpoint || 'https://api.mistral.ai/v1/chat/completions';\n    this.logger.info(`[${this.platformId}] Building API request for model: ${params.model}`);\n\n    const requestPayload = {\n      model: params.model,\n      stream: true\n    };\n\n    const messages = [];\n    // Mistral API generally prefers alternating user/assistant roles.\n    // System prompt is handled differently or sometimes prepended to the first user message.\n    // For simplicity and compatibility with OpenAI format, we'll include it if provided.\n    if (params.systemPrompt) {\n      messages.push({ role: 'system', content: params.systemPrompt });\n    }\n    if (params.conversationHistory && params.conversationHistory.length > 0) {\n      messages.push(...this._formatMistralMessages(params.conversationHistory));\n    }\n    messages.push({ role: 'user', content: prompt }); // Use the structured prompt\n    requestPayload.messages = messages;\n\n    // Apply model parameters\n    requestPayload[params.tokenParameter || 'max_tokens'] = params.maxTokens;\n    if ('temperature' in params) {\n      requestPayload.temperature = params.temperature;\n    }\n    if ('topP' in params) {\n      requestPayload.top_p = params.topP;\n    }\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(requestPayload)\n    };\n  }\n\n  /**\n   * Parse a single line/chunk from the Mistral API stream.\n   * Assumes OpenAI-compatible SSE format.\n   * @override\n   * @protected\n   * @param {string} line - A single line string from the stream.\n   * @returns {Object} Parsed result: { type: 'content' | 'done' | 'ignore' | 'error', chunk?: string, error?: string }.\n   */\n  _parseStreamChunk(line) {\n    if (!line) {\n      return { type: 'ignore' };\n    }\n\n    // Mistral uses 'data: [DONE]' like OpenAI\n    if (line === 'data: [DONE]') {\n      return { type: 'done' };\n    }\n\n    if (line.startsWith('data: ')) {\n      try {\n        const data = JSON.parse(line.substring(6));\n        const content = data.choices?.[0]?.delta?.content;\n\n        if (content) {\n          return { type: 'content', chunk: content };\n        } else {\n          // Ignore chunks without content (like finish_reason markers)\n          if (data.choices?.[0]?.finish_reason) {\n             this.logger.info(`[${this.platformId}] Stream finished with reason: ${data.choices[0].finish_reason}`);\n          }\n          return { type: 'ignore' };\n        }\n      } catch (e) {\n        this.logger.error(`[${this.platformId}] Error parsing stream chunk:`, e, 'Line:', line);\n        return { type: 'error', error: `Error parsing stream data: ${e.message}` };\n      }\n    }\n\n    return { type: 'ignore' };\n  }\n\n  /**\n   * Format conversation history for Mistral API\n   * @param {Array} history - Conversation history array\n   * @returns {Array} Formatted messages for Mistral API\n   */\n  _formatMistralMessages(history) {\n    return history.map(msg => {\n      // Map internal role names to Mistral roles (same as OpenAI format)\n      let role = 'user';\n      if (msg.role === 'assistant') role = 'assistant';\n      else if (msg.role === 'system') role = 'system';\n\n      return {\n        role,\n        content: msg.content\n      };\n    });\n  }\n\n  /**\n   * Build the platform-specific API request options for validation.\n   * @override\n   * @protected\n   * @param {string} apiKey - The API key to validate.\n   * @param {string} model - The model to use for validation.\n   * @returns {Promise<Object>} Fetch options { url, method, headers, body }.\n   */\n  async _buildValidationRequest(apiKey, model) {\n    const endpoint = this.config?.endpoint || 'https://api.mistral.ai/v1/chat/completions';\n    const validationPayload = {\n      model: model,\n      messages: [\n        { role: 'user', content: 'API validation check' }\n      ],\n      max_tokens: 1 // Minimum tokens needed\n    };\n\n    return {\n      url: endpoint,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(validationPayload)\n    };\n  }\n}\n\nmodule.exports = MistralApiService;","// src/background/api/api-coordinator.js - API model request handling\n\nimport ApiServiceManager from '../../services/ApiServiceManager.js';\nimport ModelParameterService from '../../services/ModelParameterService.js';\nimport ContentFormatter from '../../services/ContentFormatter.js';\nimport { extractContent } from '../services/content-extraction.js';\nimport { determineContentType, isInjectablePage } from '../../shared/utils/content-utils.js';\nimport { INTERFACE_SOURCES, STORAGE_KEYS } from '../../shared/constants.js';\nimport { \n  resetExtractionState, \n  initializeStreamResponse,\n  getExtractedContent,\n  setApiProcessingError,\n  completeStreamResponse,\n  hasFormattedContentForTab,\n  storeFormattedContentForTab,\n  getFormattedContentForTab,\n  storeSystemPromptForTab\n} from '../core/state-manager.js';\nimport logger from '../../shared/logger.js';\n\nconst activeAbortControllers = new Map();\n\n/**\n * Handle API model requests\n * @param {string} requestType - Type of request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response function\n */\nexport async function handleApiModelRequest(requestType, message, sendResponse) {\n  try {\n    switch (requestType) {\n      case 'checkApiModeAvailable': {\n        const platformId = message.platformId || await getPreferredAiPlatform();\n        const isAvailable = await ApiServiceManager.isApiModeAvailable(platformId);\n\n        sendResponse({\n          success: true,\n          isAvailable,\n          platformId\n        });\n        break;\n      }\n\n      case 'getApiModels': {\n        const platformId = message.platformId;\n        if (!platformId) {\n          sendResponse({ success: false, error: 'Platform ID is required to get models' });\n          return true; // Important: return true to indicate async response handled\n        }\n        const models = await ApiServiceManager.getAvailableModels(platformId);\n\n        sendResponse({\n          success: true,\n          models,\n          platformId\n        });\n        break;\n      }\n\n      case 'getApiResponse': {\n        const result = await chrome.storage.local.get([\n          STORAGE_KEYS.API_RESPONSE, \n          STORAGE_KEYS.API_PROCESSING_STATUS, \n          STORAGE_KEYS.API_RESPONSE_TIMESTAMP\n        ]);\n        \n        sendResponse({\n          success: true,\n          response: result[STORAGE_KEYS.API_RESPONSE] || null,\n          status: result[STORAGE_KEYS.API_PROCESSING_STATUS] || 'unknown',\n          timestamp: result[STORAGE_KEYS.API_RESPONSE_TIMESTAMP] || null\n        });\n        break;\n      }\n\n      case 'cancelStream': {\n            const { streamId } = message; // Ensure streamId is received\n            if (!streamId) {\n              logger.background.warn('cancelStream message received without streamId.');\n              sendResponse({ success: false, error: 'Missing streamId' });\n              break; // Exit case if no streamId\n            }\n            const controller = activeAbortControllers.get(streamId);\n            if (controller) {\n              try {\n                controller.abort();\n                activeAbortControllers.delete(streamId); // Remove immediately after aborting\n                logger.background.info(`Abort signal sent for stream: ${streamId}`);\n                sendResponse({ success: true });\n              } catch (abortError) {\n                logger.background.error(`Error aborting controller for stream ${streamId}:`, abortError);\n                sendResponse({ success: false, error: 'Failed to abort stream' });\n              }\n            } else {\n              logger.background.warn(`No active AbortController found for stream: ${streamId}`);\n              sendResponse({ success: false, error: 'Stream not found or already completed/cancelled' });\n            }\n            break; // Ensure case exits\n          }\n\n      default:\n        throw new Error(`Unknown API model request type: ${requestType}`);\n    }\n  } catch (error) {\n    logger.background.error(`Error handling API model request (${requestType}):`, error);\n    sendResponse({\n      success: false,\n      error: error.message\n    });\n  }\n}\n\n/**\n * Process content via API with streaming support\n * @param {Object} params - Parameters for content processing\n * @returns {Promise<Object>} Result information\n */\nexport async function processContentViaApi(params) {\n  const {\n    tabId,\n    url,\n    promptId = null,\n    platformId,\n    modelId,\n    source = INTERFACE_SOURCES.POPUP,\n    customPrompt = null,\n    streaming = false, // Note: streaming is forced to true later\n    conversationHistory = []\n  } = params;\n\n  if (!platformId || !modelId) {\n    const missing = [];\n    if (!platformId) missing.push('Platform ID');\n    if (!modelId) missing.push('Model ID');\n    throw new Error(`${missing.join(' and ')} are required for API processing`);\n  }\n\n  try {\n    logger.background.info(`Starting API-based content processing from ${source}`, {\n      tabId, url, promptId, platformId, modelId, streaming\n    });\n\n    let extractedContent = null;\n    let newlyFormattedContent = null; // To hold content formatted in this run\n    const contentType = determineContentType(url);\n    const skipExtractionRequested = params.skipInitialExtraction === true;\n    const isFirstUserMessage = conversationHistory.length === 0;\n    logger.background.info(`Is this the first user message (history empty)? ${isFirstUserMessage}`);\n\n    // 1. Decide whether to extract content based on existence, user request, and message history\n    const initialFormattedContentExists = await hasFormattedContentForTab(tabId);\n    // Extraction only happens on the first message, if not skipped, if content doesn't already exist, and if page is injectable.\n    const canInject = isInjectablePage(url); // Check if page allows injection\n    const shouldExtract = isFirstUserMessage && !initialFormattedContentExists && !skipExtractionRequested && canInject;\n\n    // Log if extraction is skipped specifically due to non-injectable URL on first message\n    if (isFirstUserMessage && !initialFormattedContentExists && !skipExtractionRequested && !canInject) {\n        logger.background.info(`First message: Skipping extraction for tab ${tabId} because URL (${url}) is not injectable.`);\n        // Return immediately indicating context was skipped, preventing further processing for this message\n        return {\n          success: true, // The operation itself didn't fail, it just skipped context\n          skippedContext: true,\n          reason: 'Content extraction not supported on this page type.',\n          contentType: contentType // Pass content type back if needed by UI\n        };\n    }\n\n    if (shouldExtract) {\n        logger.background.info(`First message: Extraction will proceed for tab ${tabId} (no existing content, not skipped).`);\n        // Reset previous extraction state (ensure this happens ONLY if extracting)\n        await resetExtractionState();\n\n        // Extract content\n        logger.background.info(`Content type determined: ${contentType}`);\n        await extractContent(tabId, url); // url should be available here\n        extractedContent = await getExtractedContent(); // Assign to the outer scope variable\n\n        if (!extractedContent) {\n            logger.background.warn(`Failed to extract content for tab ${tabId}, proceeding without it.`);\n            newlyFormattedContent = null; // Ensure null if extraction failed\n        } else {\n            logger.background.info('Content extraction completed.');\n            // Format and Store Content\n            logger.background.info(`Formatting extracted content (type: ${contentType})...`);\n            newlyFormattedContent = ContentFormatter.formatContent(extractedContent, contentType);\n            await storeFormattedContentForTab(tabId, newlyFormattedContent);\n            logger.background.info(`Formatted and stored content for tab ${tabId}.`);\n        }\n        // Ensure these are null if extraction happened but failed\n        if (!newlyFormattedContent) {\n             extractedContent = null;\n        }\n    } else {\n        // Log the reason why extraction was skipped\n        if (!isFirstUserMessage) {\n            logger.background.info(`Not first message: Skipping extraction for tab ${tabId}.`);\n        } else if (skipExtractionRequested) {\n            logger.background.info(`First message: Extraction skipped for tab ${tabId} by user request.`);\n        } else if (initialFormattedContentExists) {\n            logger.background.info(`First message: Formatted content already exists for tab ${tabId}, skipping extraction.`);\n        } else if (isFirstUserMessage && !canInject) {\n        } else {\n             // Should not happen based on shouldExtract logic, but log just in case\n             logger.background.warn(`Extraction skipped for unknown reason for tab ${tabId}. Conditions: isFirst=${isFirstUserMessage}, skipped=${skipExtractionRequested}, exists=${initialFormattedContentExists}, canInject=${canInject}`);\n        }\n        // Ensure these are null if extraction didn't happen\n        extractedContent = null;\n        newlyFormattedContent = null;\n    }\n\n\n    // 4. Get the prompt\n    let promptContent;\n\n    if (customPrompt) {\n      promptContent = customPrompt;\n    } else {\n      throw new Error('No prompt content provided');\n    }\n\n    // 5. Parameter Resolution (Centralized) - Use platformId and modelId from params\n    logger.background.info(`Resolving parameters for platform: ${platformId}, model: ${modelId}`);\n    let resolvedParams = await ModelParameterService.resolveParameters(\n      platformId,\n      modelId,\n      { tabId, source, conversationHistory }\n    );\n    resolvedParams.conversationHistory = conversationHistory;\n    logger.background.info(`Resolved parameters:`, resolvedParams);\n\n    // 6. Generate a unique stream ID for this request\n    const streamId = `stream_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n\n    // 7. Initialize streaming response (using platformId from params)\n    await initializeStreamResponse(streamId, platformId, resolvedParams.model); // Include model\n\n    // 8. Determine the formatted content to include in the request (only for the first message under specific conditions)\n    let formattedContentForRequest = null;\n\n    if (isFirstUserMessage) {\n        logger.background.info(`Processing first user message for content inclusion.`);\n        if (!skipExtractionRequested) {\n            logger.background.info(`Extraction was allowed for this first message.`);\n            if (shouldExtract && newlyFormattedContent) {\n                // Extraction was triggered now and succeeded\n                formattedContentForRequest = newlyFormattedContent;\n                logger.background.info(`Using newly extracted/formatted content for tab ${tabId}.`);\n            } else if (initialFormattedContentExists) {\n                // Extraction wasn't triggered now (because content existed), but it was allowed and content exists\n                formattedContentForRequest = await getFormattedContentForTab(tabId);\n                logger.background.info(`Using pre-existing formatted content for tab ${tabId}.`);\n            } else {\n                // Extraction was allowed, but either failed or wasn't triggered (and no pre-existing content)\n                logger.background.info(`No content available (extraction allowed but failed, or content didn't exist) for tab ${tabId}.`);\n                formattedContentForRequest = null;\n            }\n        } else {\n            // Extraction was explicitly skipped by the user for the first message\n            logger.background.info(`Extraction was skipped by user request for this first message. No content included.`);\n            formattedContentForRequest = null;\n        }\n    } else {\n        // Not the first message, never include content\n        logger.background.info(`Not the first user message: Skipping content inclusion.`);\n        formattedContentForRequest = null;\n    }\n\n    if (tabId) {\n      try {\n        const promptToStoreOrClear = resolvedParams.systemPrompt;\n        logger.background.info(`Updating system prompt state for tab ${tabId}. Prompt is ${promptToStoreOrClear ? 'present' : 'absent/empty'}.`);\n        await storeSystemPromptForTab(tabId, promptToStoreOrClear);\n      } catch (storeError) {\n        logger.background.error(`Failed to update system prompt state for tab ${tabId}:`, storeError);\n      }\n    }\n\n    // 9. Notify the content script about streaming start ONLY if possible and from sidebar\n    if (source === INTERFACE_SOURCES.SIDEBAR && tabId) {\n      if (isInjectablePage(url)) {\n        try {\n          await chrome.tabs.sendMessage(tabId, {\n            action: 'streamStart',\n            streamId,\n            platformId: platformId,\n            model: resolvedParams.model\n          });\n          logger.background.info(`Sent streamStart notification to content script in tab ${tabId}.`);\n        } catch (err) {\n          if (err.message && (err.message.includes('Could not establish connection') || err.message.includes('Receiving end does not exist'))) {\n             // Log the warning, but don't treat it as a fatal error for the API call itself.\n             logger.background.warn(`Failed to send streamStart to tab ${tabId}: Content script likely not running or injected.`);\n          } else {\n             logger.background.error('Error notifying content script about stream start:', err);\n          }\n        }\n      } else {\n        logger.background.info(`Skipped sending streamStart notification to tab ${tabId} (URL: ${url}) as it's not an injectable page.`);\n      }\n    }\n\n    // 10. Create unified request configuration\n    const requestConfig = {\n      prompt: promptContent,\n      resolvedParams: resolvedParams, // Pass the whole resolved params object ( includes history)\n      formattedContent: formattedContentForRequest, // Pass the formatted content string or null\n      streaming: true, // Always true for this function\n      onChunk: createStreamHandler(streamId, source, tabId, platformId, resolvedParams)\n    };\n\n    // 11. Process with API (using platformId from params)\n    const controller = new AbortController();\n    activeAbortControllers.set(streamId, controller);\n    requestConfig.abortSignal = controller.signal; // Add signal to request config\n\n    try {\n      logger.background.info('Calling ApiServiceManager.processWithUnifiedConfig with config:', requestConfig);\n      // Pass platformId from params directly\n      const apiResponse = await ApiServiceManager.processWithUnifiedConfig(\n        platformId,\n        requestConfig\n      );\n\n      // If we get here without an error, streaming completed successfully\n      return {\n        success: true,\n        streamId,\n        response: apiResponse,\n        contentType: contentType // Use the variable determined earlier\n      };\n    } catch (processingError) {\n      // Handle API processing errors\n      await setApiProcessingError(processingError.message);\n      throw processingError; // Re-throw to be caught by the outer catch\n    } finally {\n      activeAbortControllers.delete(streamId);\n      logger.background.info(`Removed AbortController for stream: ${streamId}`);\n    }\n  } catch (error) {\n    // This outer catch handles errors from setup (extraction, param resolution) AND re-thrown processing errors\n    logger.background.error('API content processing error:', error);\n    await setApiProcessingError(error.message);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n/**\n * Create a stream handler function\n * @param {string} streamId - Stream identifier\n * @param {string} source - Interface source\n * @param {number} tabId - Tab ID for sidebar integration\n * @param {string} platformId - Platform identifier\n * @param {Object} resolvedParams - Resolved parameters including the model\n * @returns {Function} Chunk handler function\n */\nfunction createStreamHandler(streamId, source, tabId, platformId, resolvedParams) {\n  let fullContent = '';\n  // Use the resolved model from the start\n  const modelToUse = resolvedParams.model;\n\n  return async function handleChunk(chunkData) {\n    if (!chunkData) return;\n\n    const chunk = typeof chunkData.chunk === 'string' ? chunkData.chunk : '';\n    const done = !!chunkData.done;\n\n    // Model should be consistent, but log if chunkData provides a different one\n    if (chunkData.model && chunkData.model !== modelToUse) {\n       logger.background.warn(`Stream chunk reported model ${chunkData.model}, but expected ${modelToUse}`);\n    }\n\n    if (chunk) {\n      fullContent += chunk;\n      \n      // Send to content script for sidebar\n      if (source === INTERFACE_SOURCES.SIDEBAR && tabId) {\n        try {\n          // Use runtime API for sidebar communication\n          chrome.runtime.sendMessage({\n            action: 'streamChunk',\n            streamId,\n            chunkData: {\n              chunk,\n              done: false,\n              model: modelToUse\n            }\n          });\n        } catch (err) {\n          logger.background.warn('Error sending stream chunk:', err);\n        }\n      }\n    }\n    \n    // Handle stream completion or error\n    if (done) {\n      const finalChunkData = {\n        chunk: '',\n        done: true,\n        model: modelToUse,\n        fullContent: chunkData.fullContent || fullContent\n      };\n\n      // Check for user cancellation first\n      if (chunkData.error === 'Cancelled by user' || (chunkData.error instanceof Error && chunkData.error.name === 'AbortError')) {\n        logger.background.info(`Stream ${streamId} cancelled by user. Processing partial content.`);\n        // Complete successfully to save partial state, but mark as cancelled for UI\n        await completeStreamResponse(fullContent, modelToUse, platformId); // No error passed\n        finalChunkData.cancelled = true; // Add cancellation flag\n        // Do NOT add finalChunkData.error\n      } else if (chunkData.error) { // Handle other errors\n        // chunkData.error should now be the pre-formatted string from extractApiErrorMessage\n        const errorMessage = chunkData.error; \n        logger.background.error(`Stream ended with error: ${errorMessage}`);\n        await setApiProcessingError(errorMessage);\n        // Pass modelToUse and error to completeStreamResponse\n        await completeStreamResponse(fullContent, modelToUse, platformId, errorMessage);\n        finalChunkData.error = errorMessage;\n      } else { // Handle successful completion\n        logger.background.info(`Stream ${streamId} completed successfully.`);\n        // Pass modelToUse to completeStreamResponse\n        await completeStreamResponse(fullContent, modelToUse, platformId);\n      }\n\n      // Ensure the final message (success, error, or cancelled) is sent for sidebar\n      if (source === INTERFACE_SOURCES.SIDEBAR && tabId) {\n        try {\n          // Use runtime API for sidebar communication\n          chrome.runtime.sendMessage({\n            action: 'streamChunk',\n            streamId,\n            chunkData: finalChunkData\n          });\n        } catch (err) {\n          logger.background.warn('Error sending stream completion/error message:', err);\n        }\n      }\n    }\n  };\n}\n","// src/background/core/message-router.js - Centralized message handling\n\nimport logger from '../../shared/logger.js';\nimport { determineContentType } from '../../shared/utils/content-utils.js';\nimport { handleCredentialOperation } from '../services/credential-manager.js';\nimport { handleApiModelRequest } from '../api/api-coordinator.js';\nimport { handleProcessContentRequest, handleProcessContentViaApiRequest } from '../services/content-processing.js';\nimport { handleToggleNativeSidePanelAction } from '../services/sidebar-manager.js';\nimport { handleThemeOperation } from '../services/theme-service.js';\nimport { handleClearTabDataRequest } from '../listeners/tab-state-listener.js';\n\n// Store for message handlers\nconst messageHandlers = new Map();\n\n/**\n * Sets up message routing system\n */\nexport function setupMessageRouter() {\n  // Register all message handlers\n  registerCoreHandlers();\n  registerApiHandlers();\n  registerServiceHandlers();\n  \n  // Set up the message listener\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    // Log the message for debugging\n    logger.background.info('Message received in background', {\n      message,\n      sender: sender.tab ? `Tab ${sender.tab.id}` : 'Extension'\n    });\n    \n    // Handle the message based on its action\n    const handler = messageHandlers.get(message.action);\n    \n    if (handler) {\n      // Call the handler and inform if it's async\n      const result = handler(message, sender, sendResponse);\n      return result === true; // Keep channel open for async response if needed\n    }\n    \n    // Default simple responses\n    if (message.action === 'checkStatus') {\n      sendResponse({ status: 'ok' });\n      return false;\n    }\n    \n    // Handle getCurrentTabId for tab-specific sidebar functionality\n    if (message.action === 'getCurrentTabId') {\n      sendResponse({ tabId: sender.tab ? sender.tab.id : null });\n      return false;\n    }\n    \n    logger.background.warn(`No handler registered for message action: ${message.action}`);\n    return false;\n  });\n  \n  logger.background.info('Message router initialized');\n}\n\n/**\n * Register core message handlers\n */\nfunction registerCoreHandlers() {\n  // Content type detection handler\n  messageHandlers.set('getContentType', (message, sender, sendResponse) => {\n    const contentType = determineContentType(message.url, message.hasSelection);\n    sendResponse({ contentType });\n    return false;\n  });\n  \n  // Status check handler\n  messageHandlers.set('checkStatus', (message, sender, sendResponse) => {\n    sendResponse({ status: 'ok' });\n    return false;\n  });\n  \n  // Error notification handler\n  messageHandlers.set('notifyError', (message, sender, sendResponse) => {\n    logger.background.error('Error from content script:', message.error);\n    return false;\n  });\n  \n  // Tab ID provider for content scripts\n  messageHandlers.set('getCurrentTabId', (message, sender, sendResponse) => {\n    if (sender.tab) {\n      sendResponse({ tabId: sender.tab.id });\n    } else {\n      sendResponse({ tabId: null, error: 'Not in a tab context' });\n    }\n    return false;\n  });\n}\n\n/**\n * Register API-related message handlers\n */\nfunction registerApiHandlers() {\n  // API mode availability check\n  messageHandlers.set('checkApiModeAvailable', (message, sender, sendResponse) => {\n    handleApiModelRequest('checkApiModeAvailable', message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n  \n  // Get API models\n  messageHandlers.set('getApiModels', (message, sender, sendResponse) => {\n    handleApiModelRequest('getApiModels', message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n  \n  // API credential operations\n  messageHandlers.set('credentialOperation', (message, sender, sendResponse) => {\n    handleCredentialOperation(message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n  \n  // API content processing\n  messageHandlers.set('processContentViaApi', (message, sender, sendResponse) => {\n    handleProcessContentViaApiRequest(message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n  \n  messageHandlers.set('cancelStream', (message, sender, sendResponse) => {\n    handleApiModelRequest('cancelStream', message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n}\n\n/**\n * Register service-related message handlers\n */\nfunction registerServiceHandlers() {\n  // Process content\n  messageHandlers.set('processContent', (message, sender, sendResponse) => {\n    handleProcessContentRequest(message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n\n  // Get theme\n  messageHandlers.set('getTheme', (message, sender, sendResponse) => {\n    handleThemeOperation(message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n\n  // Set theme\n  messageHandlers.set('setTheme', (message, sender, sendResponse) => {\n    handleThemeOperation(message, sendResponse);\n    return true; // Keep channel open for async response\n  });\n\n  // Clear specific tab data (for sidebar refresh)\n  messageHandlers.set('clearTabData', handleClearTabDataRequest);\n\n  // Handle requests to toggle the native side panel\n  messageHandlers.set('toggleNativeSidePanelAction', handleToggleNativeSidePanelAction);\n}\n","// src/background/core/state-manager.js - Background state management\n\nimport { STORAGE_KEYS } from '../../shared/constants.js';\nimport logger from '../../shared/logger.js';\n\n/**\n * Reset state to initial values\n * @returns {Promise<void>}\n */\nexport async function resetState() {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.SCRIPT_INJECTED]: false,\n      [STORAGE_KEYS.INJECTION_PLATFORM_TAB_ID]: null,\n      [STORAGE_KEYS.CONTENT_READY]: false,\n      [STORAGE_KEYS.EXTRACTED_CONTENT]: null,\n      [STORAGE_KEYS.API_PROCESSING_STATUS]: null,\n      [STORAGE_KEYS.API_RESPONSE]: null,\n    });\n  } catch (error) {\n    logger.background.error('Error resetting state:', error);\n    throw error;\n  }\n}\n\n/**\n * Store or remove the system prompt for a specific tab.\n * If systemPrompt is a non-empty string, it's stored.\n * If systemPrompt is null, undefined, or empty, the entry for the tab is removed.\n * @param {number} tabId - Tab ID to use as key.\n * @param {string | null | undefined} systemPrompt - The system prompt string to store, or null/undefined/empty to remove.\n * @returns {Promise<void>}\n */\nexport async function storeSystemPromptForTab(tabId, systemPrompt) {\n  if (typeof tabId !== 'number') {\n    logger.background.warn('storeSystemPromptForTab called with invalid tabId:', tabId);\n    return;\n  }\n\n  const key = String(tabId);\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.TAB_SYSTEM_PROMPTS);\n    // Ensure we always work with an object, even if storage is empty/corrupt\n    const allTabSystemPrompts = (result[STORAGE_KEYS.TAB_SYSTEM_PROMPTS] && typeof result[STORAGE_KEYS.TAB_SYSTEM_PROMPTS] === 'object')\n                               ? { ...result[STORAGE_KEYS.TAB_SYSTEM_PROMPTS] } // Create a mutable copy\n                               : {};\n\n    // Check if the provided prompt is a valid, non-empty string\n    if (typeof systemPrompt === 'string' && systemPrompt.trim().length > 0) {\n      // Store the valid prompt\n      if (allTabSystemPrompts[key] !== systemPrompt) { // Only update if changed\n         allTabSystemPrompts[key] = systemPrompt;\n         logger.background.info(`Stored/Updated system prompt for tab ${tabId}.`);\n         await chrome.storage.local.set({ [STORAGE_KEYS.TAB_SYSTEM_PROMPTS]: allTabSystemPrompts });\n      } else {\n         logger.background.info(`System prompt for tab ${tabId} is unchanged. No storage update needed.`);\n      }\n    } else {\n      // If prompt is invalid (null, undefined, empty), remove the key if it exists\n      if (allTabSystemPrompts.hasOwnProperty(key)) {\n        delete allTabSystemPrompts[key];\n        logger.background.info(`Removed system prompt entry for tab ${tabId} as new prompt is absent/empty.`);\n        // Save the modified object back (only if a key was actually deleted)\n        await chrome.storage.local.set({ [STORAGE_KEYS.TAB_SYSTEM_PROMPTS]: allTabSystemPrompts });\n      } else {\n        // Key doesn't exist, nothing to remove, no storage update needed.\n        logger.background.info(`No system prompt entry to remove for tab ${tabId}.`);\n      }\n    }\n  } catch (error) {\n    logger.background.error(`Error updating system prompt state for tab ${tabId}:`, error);\n  }\n}\n\n/**\n * Reset extraction state\n * @returns {Promise<void>}\n */\nexport async function resetExtractionState() {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.CONTENT_READY]: false,\n      [STORAGE_KEYS.EXTRACTED_CONTENT]: null\n    });\n    logger.background.info('Extraction state reset');\n  } catch (error) {\n    logger.background.error('Error resetting extraction state:', error);\n    throw error;\n  }\n}\n\n/**\n * Save platform tab information\n * @param {number} tabId - Tab ID of the AI platform tab\n * @param {string} platformId - Platform identifier\n * @param {string} promptContent - Prompt content to use\n * @param {string} formattedContentString - The formatted content string to save for injection.\n * @returns {Promise<boolean>} Success flag\n */\nexport async function savePlatformTabInfo(tabId, platformId, promptContent, formattedContentString) {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.INJECTION_PLATFORM_TAB_ID]: tabId,\n      [STORAGE_KEYS.INJECTION_PLATFORM]: platformId,\n      [STORAGE_KEYS.SCRIPT_INJECTED]: false,\n      [STORAGE_KEYS.PRE_PROMPT]: promptContent,\n      [STORAGE_KEYS.FORMATTED_CONTENT_FOR_INJECTION]: formattedContentString,\n    });\n    \n    // Verify the data was stored correctly\n    const verifyData = await chrome.storage.local.get([STORAGE_KEYS.INJECTION_PLATFORM_TAB_ID, STORAGE_KEYS.INJECTION_PLATFORM, STORAGE_KEYS.SCRIPT_INJECTED]);\n    logger.background.info(`Storage verification: aiPlatformTabId=${verifyData[STORAGE_KEYS.INJECTION_PLATFORM_TAB_ID]}, aiPlatform=${verifyData[STORAGE_KEYS.INJECTION_PLATFORM]}, scriptInjected=${verifyData[STORAGE_KEYS.SCRIPT_INJECTED]}`);\n    \n    return true;\n  } catch (error) {\n    logger.background.error('Error saving platform tab info:', error);\n    return false;\n  }\n}\n\n/**\n * Update script injection status\n * @param {boolean} injected - Whether script was injected\n * @returns {Promise<void>}\n */\nexport async function updateScriptInjectionStatus(injected) {\n  try {\n    await chrome.storage.local.set({ [STORAGE_KEYS.SCRIPT_INJECTED]: injected });\n    logger.background.info(`Updated script injection status: ${injected}`);\n  } catch (error) {\n    logger.background.error('Error updating script injection status:', error);\n  }\n}\n\n/**\n * Save extracted content\n * @param {Object} content - Extracted content object\n * @returns {Promise<void>}\n */\nexport async function saveExtractedContent(content) {\n  try {\n    await chrome.storage.local.set({ \n      [STORAGE_KEYS.EXTRACTED_CONTENT]: content,\n      [STORAGE_KEYS.CONTENT_READY]: true\n    });\n    logger.background.info('Extracted content saved');\n  } catch (error) {\n    logger.background.error('Error saving extracted content:', error);\n  }\n}\n\n/**\n * Save API streaming response\n * @param {string} streamId - Stream identifier\n * @param {string} platformId - Platform identifier\n * @returns {Promise<void>}\n */\nexport async function initializeStreamResponse(streamId, platformId) {\n  try {\n    const initialResponse = {\n      success: true,\n      streamId,\n      status: 'streaming',\n      platformId,\n      timestamp: Date.now(),\n      content: '' // Will be populated as streaming progresses\n    };\n\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.API_PROCESSING_STATUS]: 'streaming',\n      [STORAGE_KEYS.API_RESPONSE]: initialResponse,\n      [STORAGE_KEYS.STREAM_ID]: streamId\n    });\n    logger.background.info(`Stream response initialized: ${streamId}`);\n  } catch (error) {\n    logger.background.error('Error initializing stream response:', error);\n  }\n}\n\n/**\n * Complete stream response\n * @param {string} fullContent - Complete final content\n * @param {string} model - Model used\n * @param {string} platformId - Platform identifier\n * @param {string|null} [error=null] - Optional error message if the stream failed\n * @returns {Promise<void>}\n */\nexport async function completeStreamResponse(fullContent, model, platformId, error = null) {\n  try {\n    let finalResponse;\n    let storageUpdate = {};\n\n    if (error) {\n      // Handle error case\n      finalResponse = {\n        success: false,\n        status: 'error',\n        content: fullContent, // Include content received before error\n        model,\n        platformId,\n        error: error, // Include the error message\n        timestamp: Date.now()\n      };\n      storageUpdate = {\n        [STORAGE_KEYS.API_PROCESSING_STATUS]: 'error',\n        [STORAGE_KEYS.API_PROCESSING_ERROR]: error,\n        [STORAGE_KEYS.API_RESPONSE]: finalResponse,\n        [STORAGE_KEYS.API_RESPONSE_TIMESTAMP]: Date.now()\n      };\n      logger.background.error(`Stream response completed with error: ${error}`);\n    } else {\n      // Handle success case\n      finalResponse = {\n        success: true,\n        status: 'completed',\n        content: fullContent,\n        model,\n        platformId,\n        timestamp: Date.now()\n      };\n      storageUpdate = {\n        [STORAGE_KEYS.API_PROCESSING_STATUS]: 'completed',\n        [STORAGE_KEYS.API_RESPONSE]: finalResponse,\n        [STORAGE_KEYS.API_RESPONSE_TIMESTAMP]: Date.now(),\n        [STORAGE_KEYS.API_PROCESSING_ERROR]: null\n      };\n      logger.background.info('Stream response completed successfully');\n    }\n    \n    // Update storage\n    await chrome.storage.local.set(storageUpdate);\n    \n    // Notify the popup and potentially other listeners\n    try {\n      // Send the final response object\n      chrome.runtime.sendMessage({\n        action: 'apiResponseReady',\n        response: finalResponse\n      });\n    } catch (msgError) {\n      // Ignore if popup isn't open or other listeners fail\n      logger.background.info('Could not notify listeners of API response completion/error:', msgError.message);\n    }\n  } catch (catchError) {\n    logger.background.error('Error in completeStreamResponse function:', catchError);\n    // Attempt to set a generic error state if something goes wrong here\n    try {\n      await chrome.storage.local.set({\n        [STORAGE_KEYS.API_PROCESSING_STATUS]: 'error',\n        [STORAGE_KEYS.API_PROCESSING_ERROR]: 'Internal error completing stream response'\n      });\n    } catch (fallbackError) {\n       logger.background.error('Failed to set fallback error state:', fallbackError);\n    }\n  }\n}\n\n/**\n * Set API processing error\n * @param {string} error - Error message\n * @returns {Promise<void>}\n */\nexport async function setApiProcessingError(error) {\n  try {\n    await chrome.storage.local.set({\n      [STORAGE_KEYS.API_PROCESSING_STATUS]: 'error',\n      [STORAGE_KEYS.API_PROCESSING_ERROR]: error\n    });\n    logger.background.error('API processing error set:', error);\n    \n    // Notify popup if open\n    try {\n      chrome.runtime.sendMessage({\n        action: 'apiProcessingError',\n        error\n      });\n    } catch (msgError) {\n      // Ignore if popup isn't open\n    }\n  } catch (err) {\n    logger.background.error('Error setting API processing error:', err);\n  }\n}\n\n/**\n * Check if formatted content exists for a specific tab.\n * Assumes content is stored under STORAGE_KEYS.TAB_FORMATTED_CONTENT\n * with tab IDs as keys.\n * @param {number} tabId - The ID of the tab to check.\n * @returns {Promise<boolean>} True if formatted content exists, false otherwise.\n */\nexport async function hasFormattedContentForTab(tabId) {\n  if (typeof tabId !== 'number') {\n    logger.background.warn('hasFormattedContentForTab called with invalid tabId:', tabId);\n    return false;\n  }\n  const key = String(tabId); // Ensure key is a string if needed\n  try {\n    // Note: The original request mentioned STORAGE_KEYS.TAB_FORMATTED_CONTENT\n    // Adjust this key if the actual storage key is different.\n    const result = await chrome.storage.local.get(STORAGE_KEYS.TAB_FORMATTED_CONTENT);\n    const allFormattedContent = result[STORAGE_KEYS.TAB_FORMATTED_CONTENT];\n    \n    if (allFormattedContent && typeof allFormattedContent === 'object' && allFormattedContent.hasOwnProperty(key)) {\n      logger.background.info(`Formatted content found for tab ${tabId}.`);\n      return true;\n    } else {\n      logger.background.info(`No formatted content found for tab ${tabId}.`);\n      return false;\n    }\n  } catch (error) {\n    logger.background.error(`Error checking formatted content for tab ${tabId}:`, error);\n    return false; // Assume no content on error\n  }\n}\n\n/**\n * Store formatted content in local storage by tab ID.\n * Assumes content is stored under STORAGE_KEYS.TAB_FORMATTED_CONTENT\n * with tab IDs as keys.\n * @param {number} tabId - Tab ID to use as key.\n * @param {string} formattedContent - The formatted content string to store.\n * @returns {Promise<void>}\n */\nexport async function storeFormattedContentForTab(tabId, formattedContent) {\n  if (typeof tabId !== 'number') {\n    logger.background.warn('storeFormattedContentForTab called with invalid tabId:', tabId);\n    return;\n  }\n  if (typeof formattedContent !== 'string') {\n    logger.background.warn('storeFormattedContentForTab called with non-string content for tabId:', tabId);\n    return;\n  }\n\n  const key = String(tabId);\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.TAB_FORMATTED_CONTENT);\n    const allFormattedContent = result[STORAGE_KEYS.TAB_FORMATTED_CONTENT] || {};\n\n    allFormattedContent[key] = formattedContent;\n\n    await chrome.storage.local.set({ [STORAGE_KEYS.TAB_FORMATTED_CONTENT]: allFormattedContent });\n    logger.background.info(`Stored formatted content for tab ${tabId}.`);\n  } catch (error) {\n    logger.background.error(`Error storing formatted content for tab ${tabId}:`, error);\n    throw error; // Re-throw error for the caller to handle\n  }\n}\n\n/**\n * Get formatted content for a specific tab.\n * Assumes content is stored under STORAGE_KEYS.TAB_FORMATTED_CONTENT\n * with tab IDs as keys.\n * @param {number} tabId - The ID of the tab to retrieve content for.\n * @returns {Promise<string|null>} The formatted content string, or null if not found or on error.\n */\nexport async function getFormattedContentForTab(tabId) {\n  if (typeof tabId !== 'number') {\n    logger.background.warn('getFormattedContentForTab called with invalid tabId:', tabId);\n    return null;\n  }\n  const key = String(tabId);\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.TAB_FORMATTED_CONTENT);\n    const allFormattedContent = result[STORAGE_KEYS.TAB_FORMATTED_CONTENT];\n\n    if (allFormattedContent && typeof allFormattedContent === 'object' && allFormattedContent.hasOwnProperty(key)) {\n      logger.background.info(`Retrieved formatted content for tab ${tabId}.`);\n      return allFormattedContent[key]; // Return the stored string\n    } else {\n      logger.background.info(`No formatted content found for tab ${tabId} during retrieval.`);\n      return null;\n    }\n  } catch (error) {\n    logger.background.error(`Error retrieving formatted content for tab ${tabId}:`, error);\n    return null; // Return null on error\n  }\n}\n\n\n/**\n * Get stored content extraction\n * @returns {Promise<Object>} Extracted content\n */\nexport async function getExtractedContent() {\n  try {\n    const { extractedContent } = await chrome.storage.local.get(STORAGE_KEYS.EXTRACTED_CONTENT);\n    return extractedContent;\n  } catch (error) {\n    logger.background.error('Error getting extracted content:', error);\n    return null;\n  }\n}\n\n/**\n * Get current AI platform tab information\n * @returns {Promise<Object>} Platform tab info\n */\nexport async function getPlatformTabInfo() {\n  try {\n    const result = await chrome.storage.local.get([STORAGE_KEYS.INJECTION_PLATFORM_TAB_ID, STORAGE_KEYS.INJECTION_PLATFORM, STORAGE_KEYS.SCRIPT_INJECTED]);\n    return {\n      tabId: result[STORAGE_KEYS.INJECTION_PLATFORM_TAB_ID],\n      platformId: result[STORAGE_KEYS.INJECTION_PLATFORM],\n      scriptInjected: result[STORAGE_KEYS.SCRIPT_INJECTED]\n    };\n  } catch (error) {\n    logger.background.error('Error getting platform tab info:', error);\n    return {\n      tabId: null,\n      platformId: null,\n      scriptInjected: false\n    };\n  }\n}\n","// src/background/initialization.js - Handles extension initialization\n\nimport { resetState } from './core/state-manager.js';\nimport logger from '../shared/logger.js';\nimport { STORAGE_KEYS } from '../shared/constants.js';\n\n/**\n * Initializes default prompts from prompt-config.json into sync storage\n * if they haven't been initialized before. This should only run once.\n */\nasync function initializeDefaultPrompts() {\n  // This log should now appear if the function is called correctly\n  logger.background.info('Attempting to initialize default prompts...');\n  try {\n    // Fetch default prompts from config file\n    const response = await fetch(chrome.runtime.getURL('prompt-config.json'));\n    if (!response.ok) {\n      throw new Error(`Failed to fetch prompt-config.json: ${response.statusText}`);\n    }\n    const defaultPromptsConfig = await response.json();\n\n    // Fetch existing custom prompts from sync storage\n    const syncResult = await chrome.storage.sync.get(STORAGE_KEYS.CUSTOM_PROMPTS);\n    const promptsByType = typeof syncResult[STORAGE_KEYS.CUSTOM_PROMPTS] === 'object' && syncResult[STORAGE_KEYS.CUSTOM_PROMPTS] !== null\n      ? syncResult[STORAGE_KEYS.CUSTOM_PROMPTS]\n      : {};\n\n    let promptsAdded = false;\n\n    // Iterate through content types in the default config\n    for (const contentType in defaultPromptsConfig) {\n      if (Object.hasOwnProperty.call(defaultPromptsConfig, contentType)) {\n        // Ensure the content type exists in the sync storage structure\n        if (!promptsByType[contentType]) {\n          promptsByType[contentType] = { prompts: {} };\n        } else if (typeof promptsByType[contentType].prompts !== 'object' || promptsByType[contentType].prompts === null) {\n          promptsByType[contentType].prompts = {};\n        }\n\n        const defaultPromptsForType = defaultPromptsConfig[contentType];\n\n        // Iterate through prompts defined for this content type in the default config\n        for (const defaultPromptName in defaultPromptsForType) {\n          if (Object.hasOwnProperty.call(defaultPromptsForType, defaultPromptName)) {\n            const defaultPromptContent = defaultPromptsForType[defaultPromptName];\n\n            // Check if a prompt with the same name already exists in sync storage for this type\n            const existingPrompts = promptsByType[contentType].prompts;\n            const nameExists = Object.values(existingPrompts).some(\n              (prompt) => prompt && typeof prompt === 'object' && prompt.name === defaultPromptName\n            );\n\n            if (!nameExists) {\n              // Prompt doesn't exist, create and add it\n              const newPromptId = `prompt_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n              const now = new Date().toISOString();\n              const newPrompt = {\n                id: newPromptId,\n                name: defaultPromptName,\n                content: defaultPromptContent,\n                contentType: contentType, // Use the key from the config\n                createdAt: now,\n                updatedAt: now,\n              };\n              promptsByType[contentType].prompts[newPromptId] = newPrompt;\n              promptsAdded = true;\n              logger.background.info(`Added default prompt: \"${defaultPromptName}\" for type \"${contentType}\"`);\n            } else {\n              logger.background.info(`Default prompt \"${defaultPromptName}\" for type \"${contentType}\" already exists. Skipping.`);\n            }\n          }\n        }\n      }\n    }\n\n    // Save back to sync storage if any prompts were added\n    if (promptsAdded) {\n      await chrome.storage.sync.set({ [STORAGE_KEYS.CUSTOM_PROMPTS]: promptsByType });\n      logger.background.info('Successfully added default prompts to sync storage.');\n    } else {\n      logger.background.info('No new default prompts needed to be added.');\n    }\n\n    // Return true indicating success (or at least completion without error)\n    return true;\n\n  } catch (error) {\n    logger.background.error('Error initializing default prompts:', error);\n    // Return false indicating failure\n    return false;\n  }\n}\n\n/**\n * Initialize the extension's core configuration and state.\n * Should run on install and update.\n */\nexport async function initializeExtension() {\n  logger.background.info('Running core extension initialization...');\n  try {\n    await resetState();\n    logger.background.info('Volatile state reset complete');\n\n    // Reset all tab sidebar visibility states to false\n    logger.background.info('Resetting all tab sidebar visibility states to false...');\n    const tabs = await chrome.tabs.query({});\n    const initialSidebarStates = {};\n    for (const tab of tabs) {\n      if (tab.id) {\n        initialSidebarStates[tab.id.toString()] = false;\n      }\n    }\n    await chrome.storage.local.set({ \n      [STORAGE_KEYS.TAB_SIDEBAR_STATES]: initialSidebarStates \n    });\n    logger.background.info('All tab sidebar visibility states reset.');\n\n    return true;\n  } catch (error) {\n    logger.background.error('Core initialization error:', error);\n    throw error;\n  }\n}\n\n/**\n * Handle extension installation or update event.\n * @param {Object} details - Installation details (reason: \"install\", \"update\", \"chrome_update\")\n */\nexport async function handleInstallation(details) {\n  logger.background.info(`Extension event: ${details.reason}`, details);\n\n  // --- Default Prompt Initialization Logic ---\n  if (details.reason === 'install') {\n    logger.background.info('Reason is \"install\", checking default prompt initialization flag...');\n    const flagKey = STORAGE_KEYS.DEFAULT_PROMPTS_INIT_FLAG;\n    try {\n      const flagResult = await chrome.storage.local.get(flagKey);\n      if (!flagResult[flagKey]) { // Only run if flag is not true\n        logger.background.info('Initialization flag not set. Proceeding with default prompt initialization.');\n        const promptInitSuccess = await initializeDefaultPrompts();\n        if (promptInitSuccess) {\n          // Set the flag only if initialization completed successfully\n          await chrome.storage.local.set({ [flagKey]: true });\n          logger.background.info('Set default prompts initialization flag.');\n        } else {\n           logger.background.warn('Default prompt initialization failed. Flag not set.');\n        }\n      } else {\n        logger.background.info('Default prompts initialization flag is already set. Skipping.');\n      }\n    } catch (error) {\n      logger.background.error('Error during default prompt initialization check:', error);\n    }\n  } else {\n     logger.background.info(`Reason is \"${details.reason}\", skipping default prompt initialization.`);\n  }\n\n  // --- Core Initialization ---\n  // Run general initialization on both install and update.\n  // It's generally safe to run this multiple times.\n  try {\n    await initializeExtension();\n    logger.background.info('Core extension initialization completed.');\n  } catch(error) {\n     logger.background.error('Failed to complete core extension initialization after install/update event.');\n  }\n}\n\n// Setup installation handler\nchrome.runtime.onInstalled.addListener(handleInstallation);\n","// src/background/listeners/tab-listener.js - Tab update monitoring\n\nimport { isPlatformTab, getPlatformContentScript } from '../services/platform-integration.js';\nimport { injectContentScript } from '../services/content-extraction.js';\nimport { getPlatformTabInfo, updateScriptInjectionStatus } from '../core/state-manager.js';\nimport SidebarStateManager from '../../services/SidebarStateManager.js';\nimport logger from '../../shared/logger.js';\nimport { STORAGE_KEYS } from '../../shared/constants.js';\nimport { determineContentType } from '../../shared/utils/content-utils.js';\n\n/**\n * Set up tab update and activation listeners\n */\nexport function setupTabListener() {\n  chrome.tabs.onUpdated.addListener(handleTabUpdate);\n  chrome.tabs.onActivated.addListener(handleTabActivation); // Add activation listener\n  chrome.tabs.onCreated.addListener(handleTabCreation); // Add creation listener\n  logger.background.info('Tab update, activation, and creation listeners initialized'); // Update log message\n}\n\n/**\n * Handle tab update events\n * @param {number} tabId - Tab ID that was updated\n * @param {Object} changeInfo - Information about the change\n * @param {Object} tab - Tab information\n */\nasync function handleTabUpdate(tabId, changeInfo, tab) {\n  // --- Platform Tab Injection Logic ---\n  if (changeInfo.status === 'complete' && tab.url) {\n    try {\n      // Get the current AI platform tab information\n    const { tabId: aiPlatformTabId, platformId, scriptInjected } = await getPlatformTabInfo();\n\n    // Check if this is our AI platform tab\n    if (tabId !== aiPlatformTabId || scriptInjected) {\n      return;\n    }\n\n    // Check if this is a platform tab based on URL\n    const isPlatform = isPlatformTab(tabId, tab.url, platformId);\n    if (!isPlatform) {\n      return;\n    }\n\n    logger.background.info(`${platformId} tab detected and loaded: ${tabId}`, { url: tab.url });\n\n    // Get the appropriate content script\n    const contentScript = getPlatformContentScript(platformId);\n\n    // Inject content script\n    logger.background.info(`Injecting ${platformId} content script into tab: ${tabId}`);\n    const injectionSuccess = await injectContentScript(tabId, contentScript);\n\n    if (!injectionSuccess) {\n      logger.background.error(`Failed to inject platform content script for ${platformId}`);\n      return;\n    }\n\n    logger.background.info(`Setting scriptInjected flag to true for tab: ${tabId}`);\n    await updateScriptInjectionStatus(true);\n\n    // Verify extracted content is available\n    const { extractedContent } = await chrome.storage.local.get(STORAGE_KEYS.EXTRACTED_CONTENT);\n    logger.background.info('Content available for AI platform:', {\n      hasContent: !!extractedContent,\n      contentType: extractedContent?.contentType\n    });\n  } catch (error) {\n      logger.background.error(`Error handling platform tab injection for tab ${tabId}:`, error);\n    }\n  }\n\n  // --- Side Panel Navigation Detection Logic ---\n  // Check if the URL changed or the tab finished loading (status === 'complete')\n  if ((changeInfo.status === 'complete' || changeInfo.url) && tab.url) {\n    try {\n      // Check if the side panel is *intended* to be visible for this tab\n      const isVisible = await SidebarStateManager.getSidebarVisibilityForTab(tabId);\n\n      if (isVisible) {\n        logger.background.info(`Tab ${tabId} navigated to ${tab.url}. Side panel is relevant. Checking content type.`);\n        const newContentType = determineContentType(tab.url);\n\n        // Send message to the runtime (listened to by SidebarApp)\n        chrome.runtime.sendMessage({\n          action: 'pageNavigated',\n          tabId: tabId,\n          newUrl: tab.url,\n          newContentType: newContentType\n        });\n        logger.background.info(`Sent 'pageNavigated' message for tab ${tabId} with new URL and type: ${newContentType}`);\n      }\n      // No need for an else block, if not visible, we do nothing.\n    } catch (error) {\n      logger.background.error(`Error handling side panel navigation detection for tab ${tabId}:`, error);\n    }\n  }\n}\n\n/**\n * Handle tab activation events to set the side panel state\n * @param {Object} activeInfo - Information about the activated tab\n * @param {number} activeInfo.tabId - The ID of the activated tab\n */\nasync function handleTabActivation(activeInfo) {\n  const { tabId } = activeInfo;\n  logger.background.info(`Tab activation handler running for tabId: ${tabId}`);\n\n  try {\n    // Retrieve the intended visibility state for the activated tab\n    const isVisible = await SidebarStateManager.getSidebarVisibilityForTab(tabId);\n    // Removed log printing retrieved visibility state\n\n    // Conditionally set side panel options based on stored visibility\n    if (isVisible) {\n      // Enable and set the path ONLY if it should be visible\n      await chrome.sidePanel.setOptions({\n        tabId: tabId,\n        path: `sidepanel.html?tabId=${tabId}`,\n        enabled: true\n      });\n      logger.background.info(`Side panel enabled for activated tab ${tabId}`); // Simplified log\n    } else {\n      // Disable the panel if it shouldn't be visible\n      await chrome.sidePanel.setOptions({\n        tabId: tabId,\n        enabled: false\n      });\n      logger.background.info(`Side panel disabled for activated tab ${tabId}`);\n    }\n\n  } catch (error) {\n    logger.background.error(`Error setting side panel options for activated tab ${tabId}:`, error);\n  }\n}\n\n/**\n * Handle tab creation events to initialize side panel state\n * @param {Object} newTab - Information about the newly created tab\n */\nasync function handleTabCreation(newTab) {\n  logger.background.info(`Tab creation handler running for new tabId: ${newTab.id}`);\n  try {\n    // Store the initial visibility state (false) without enabling/disabling the panel itself\n    await SidebarStateManager.setSidebarVisibilityForTab(newTab.id, false);\n    logger.background.info(`Initial sidebar state (visible: false) stored for new tab ${newTab.id}`);\n  } catch (error) {\n    logger.background.error(`Error storing initial side panel state for new tab ${newTab.id}:`, error);\n  }\n}\n","// src/background/listeners/tab-state-listener.js\n\nimport { STORAGE_KEYS } from '../../shared/constants.js';\nimport SidebarStateManager from '../../services/SidebarStateManager.js';\nimport logger from '../../shared/logger.js';\n\n// List of tab-specific storage keys to clear on manual refresh (excluding sidebar visibility)\nconst TAB_SPECIFIC_DATA_KEYS_TO_CLEAR = [\n  STORAGE_KEYS.TAB_CHAT_HISTORIES,\n  STORAGE_KEYS.TAB_TOKEN_STATISTICS,\n  STORAGE_KEYS.TAB_SYSTEM_PROMPTS,\n  STORAGE_KEYS.TAB_MODEL_PREFERENCES,\n  STORAGE_KEYS.TAB_PLATFORM_PREFERENCES,\n  STORAGE_KEYS.TAB_FORMATTED_CONTENT,\n  // Note: TAB_SIDEBAR_STATES is intentionally excluded to preserve visibility state during manual refresh.\n];\n\n// List of all storage keys that are tab-specific and need automatic cleanup (used for onRemoved/periodic cleanup)\n// This includes TAB_SIDEBAR_STATES which is handled by SidebarStateManager.cleanupTabStates\nconst ALL_TAB_SPECIFIC_KEYS_FOR_CLEANUP = [\n  STORAGE_KEYS.TAB_FORMATTED_CONTENT,\n  STORAGE_KEYS.TAB_PLATFORM_PREFERENCES,\n  STORAGE_KEYS.TAB_MODEL_PREFERENCES,\n  STORAGE_KEYS.TAB_SIDEBAR_STATES, // Included for the loop, but handled separately\n  STORAGE_KEYS.TAB_CHAT_HISTORIES,\n  STORAGE_KEYS.TAB_TOKEN_STATISTICS,\n  STORAGE_KEYS.TAB_SYSTEM_PROMPTS\n];\n\n/**\n * Clears specified storage data for a single tab.\n * Used for the manual refresh action initiated from the UI.\n * @param {number} tabId - The ID of the tab to clear data for.\n * @returns {Promise<boolean>} - True if successful, false otherwise.\n */\nexport async function clearSingleTabData(tabId) {\n  if (typeof tabId !== 'number') {\n    logger.background.error('clearSingleTabData called with invalid tabId:', tabId);\n    return false;\n  }\n  const tabIdStr = tabId.toString();\n  logger.background.info(`Clearing specific data for tab ${tabIdStr}...`);\n\n  try {\n    for (const storageKey of TAB_SPECIFIC_DATA_KEYS_TO_CLEAR) { // Use the manual refresh list\n      const result = await chrome.storage.local.get(storageKey);\n      const data = result[storageKey];\n\n      if (data && typeof data === 'object' && data[tabIdStr] !== undefined) {\n        logger.background.info(`Found data for key ${storageKey} for tab ${tabIdStr}. Deleting...`);\n        delete data[tabIdStr];\n        await chrome.storage.local.set({ [storageKey]: data });\n        logger.background.info(`Cleared ${storageKey} for tab ${tabIdStr}.`);\n      } else {\n         logger.background.info(`No data found for key ${storageKey} for tab ${tabIdStr}. Skipping.`);\n      }\n    }\n    logger.background.info(`Successfully cleared specified data for tab ${tabIdStr}.`);\n    return true;\n  } catch (error) {\n    logger.background.error(`Error clearing data for tab ${tabIdStr}:`, error);\n    return false;\n  }\n}\n\n/**\n * Handles the 'clearTabData' message request from the UI (e.g., sidebar refresh button).\n * @param {object} message - The message object containing the tabId.\n * @param {chrome.runtime.MessageSender} sender - The sender of the message.\n * @param {function} sendResponse - Function to call to send the response.\n * @returns {boolean} - True to indicate an asynchronous response.\n */\nexport function handleClearTabDataRequest(message, sender, sendResponse) {\n  if (!message.tabId) {\n    logger.background.error('handleClearTabDataRequest called without tabId');\n    sendResponse({ success: false, error: 'Missing tabId' });\n    return false; // Return false as sendResponse is called synchronously here\n  }\n\n  // Call the async function and handle the promise explicitly\n  clearSingleTabData(message.tabId)\n    .then(success => {\n      if (success) {\n        logger.background.info(`handleClearTabDataRequest successful for tab ${message.tabId}, sending success response.`);\n        sendResponse({ success: true });\n      } else {\n        logger.background.warn(`handleClearTabDataRequest failed for tab ${message.tabId}, sending failure response.`);\n        sendResponse({ success: false, error: 'Failed to clear tab data in background' });\n      }\n    })\n    .catch(error => {\n      logger.background.error('Error during clearSingleTabData execution in handler:', error);\n      sendResponse({ success: false, error: 'Internal error during tab data clearing' });\n    });\n\n  return true; // Keep channel open for async response\n}\n\n/**\n * Clean up a specific tab-based storage item. Used internally by automatic cleanup processes.\n * @param {string} storageKey - The storage key to clean up (e.g., STORAGE_KEYS.TAB_CHAT_HISTORIES).\n * @param {number|null} tabId - Tab ID to remove (for single tab cleanup on close). If null, uses validTabIds.\n * @param {Set<number>|null} [validTabIds=null] - Set of currently open tab IDs (for periodic cleanup). If null, uses tabId.\n * @returns {Promise<boolean>} - True if changes were made, false otherwise.\n */\nasync function cleanupTabStorage(storageKey, tabId, validTabIds = null) {\n  try {\n    // Get the current storage data for the specified key\n    const storageData = await chrome.storage.local.get(storageKey);\n    if (!storageData[storageKey] || typeof storageData[storageKey] !== 'object') {\n      return false; // No data or invalid data structure for this key, no changes needed\n    }\n\n    const currentData = storageData[storageKey];\n    let updatedData = { ...currentData }; // Create a mutable copy to modify\n    let hasChanges = false;\n\n    if (validTabIds instanceof Set) {\n      // Periodic Cleanup Mode (onStartup / Service Worker Wake-up) ---\n      // Remove entries for tabs that are NOT in the validTabIds set.\n      for (const storedTabIdStr of Object.keys(updatedData)) {\n        const storedTabId = parseInt(storedTabIdStr, 10);\n        // Check if the stored ID is valid number AND if it's NOT present in the set of currently open tabs\n        if (isNaN(storedTabId) || !validTabIds.has(storedTabId)) {\n          delete updatedData[storedTabIdStr]; // Delete data for the closed/invalid tab\n          hasChanges = true;\n          logger.background.info(`Periodic cleanup: Removed stale ${storageKey} data for tab ID ${storedTabIdStr}`);\n        }\n        // If the storedTabId *is* in validTabIds, it's kept.\n      }\n    } else if (typeof tabId === 'number') {\n      // Single Tab Cleanup Mode (onRemoved) ---\n      // Remove the entry specifically for the closed tab ID.\n      const tabIdStr = tabId.toString();\n      if (updatedData.hasOwnProperty(tabIdStr)) {\n        delete updatedData[tabIdStr];\n        hasChanges = true;\n        logger.background.info(`onRemoved cleanup: Removed ${storageKey} data for tab ${tabIdStr}.`);\n      }\n    } else {\n      // Invalid parameters for cleanup mode\n      logger.background.warn(`cleanupTabStorage called with invalid parameters for ${storageKey}. Mode ambiguity.`);\n      return false;\n    }\n\n    // Save changes back to storage only if modifications were made\n    if (hasChanges) {\n      await chrome.storage.local.set({\n        [storageKey]: updatedData\n      });\n      logger.background.info(`Successfully saved updated data for ${storageKey} after cleanup.`);\n    }\n\n    return hasChanges;\n  } catch (error) {\n    logger.background.error(`Error cleaning up ${storageKey}:`, error);\n    return false; // Indicate failure on error\n  }\n}\n\n\n/**\n * Set up tab state cleanup listeners (Handles tab removal).\n */\nexport function setupTabStateListener() {\n  // Clean up tab states when tabs are closed\n  chrome.tabs.onRemoved.addListener(async (tabId /* removedTabId */, removeInfo) => {\n    // Check if the browser window is closing; if so, onStartup cleanup will handle it later.\n    if (removeInfo.isWindowClosing) {\n        logger.background.info(`Window closing, skipping onRemoved cleanup for tab ${tabId}. Startup cleanup will handle.`);\n        return;\n    }\n\n    logger.background.info(`Tab ${tabId} closed, cleaning up tab-specific state via onRemoved.`);\n\n    try {\n      // Clean up all general tab-specific storage keys\n      for (const storageKey of ALL_TAB_SPECIFIC_KEYS_FOR_CLEANUP) {\n         // Skip sidebar state in this loop; handled separately below.\n         if (storageKey !== STORAGE_KEYS.TAB_SIDEBAR_STATES) {\n            await cleanupTabStorage(storageKey, tabId, null); // Pass tabId for single removal, validTabIds=null\n         }\n      }\n      logger.background.info(`General tab data cleanup completed for closed tab ${tabId}.`);\n\n      // Use SidebarStateManager to specifically clean its state for the removed tab\n      await SidebarStateManager.cleanupTabStates([tabId], null); // Pass removed tabId for targeted cleanup\n      logger.background.info(`Sidebar state cleanup completed for closed tab ${tabId}.`);\n\n    } catch (error) {\n      logger.background.error(`Error cleaning up tab-specific data on tab removal (tabId: ${tabId}):`, error);\n    }\n\n    // Also attempt to disable the side panel for the closed tab, if it was enabled.\n    // This might fail if the tab is truly gone, so catch errors gracefully.\n    logger.background.info(`Attempting to disable side panel for closed tab ${tabId}`);\n    try {\n        await chrome.sidePanel.setOptions({ tabId: tabId, enabled: false });\n        logger.background.info(`Successfully requested side panel disable for closed tab ${tabId}.`);\n    } catch (err) {\n        // Log warning, but don't throw - tab might already be gone or panel wasn't open/relevant\n        logger.background.warn(`Could not disable side panel for closed tab ${tabId} (likely expected):`, err.message);\n    }\n  });\n\n  logger.background.info('Tab state listener initialized (cleanup onRemoved).');\n}\n\n/**\n * Performs cleanup of stale tab-specific data from storage based on currently open tabs.\n * Iterates through known tab-specific keys and removes entries for tabs that no longer exist.\n * This function is called on browser startup and service worker initialization.\n */\nexport async function performStaleTabCleanup() {\n  logger.background.info('Running stale tab data cleanup...');\n  try {\n    // Get all currently open tabs\n    const tabs = await chrome.tabs.query({});\n    const validTabIds = new Set(tabs.map(tab => tab.id)); // Set of IDs for open tabs\n    logger.background.info(`Found ${validTabIds.size} currently open tabs.`);\n\n    // Clean up all general tab-specific storage keys based on the valid IDs\n    for (const storageKey of ALL_TAB_SPECIFIC_KEYS_FOR_CLEANUP) {\n       // Skip sidebar state in this loop; handled separately below.\n       if (storageKey !== STORAGE_KEYS.TAB_SIDEBAR_STATES) {\n          await cleanupTabStorage(storageKey, null, validTabIds); // Pass validTabIds for periodic removal, tabId=null\n       }\n    }\n    logger.background.info(`General stale tab data cleanup processing completed.`);\n\n    // Use SidebarStateManager to clean its state based on valid IDs\n    await SidebarStateManager.cleanupTabStates(null, validTabIds); // Pass validTabIds for periodic cleanup\n    logger.background.info(`Sidebar stale state cleanup completed.`);\n\n    logger.background.info('Stale tab data cleanup finished successfully.');\n  } catch (error) {\n    logger.background.error('Error during stale tab data cleanup execution:', error);\n  }\n}","// src/background/services/content-extraction.js - Content extraction coordination\n\nimport { determineContentType, isInjectablePage } from '../../shared/utils/content-utils.js'; // Import isInjectablePage\nimport { STORAGE_KEYS } from '../../shared/constants.js';\nimport logger from '../../shared/logger.js';\n\n/**\n * Extract content from a tab\n * @param {number} tabId - Tab ID to extract content from\n * @param {string} url - URL of the page\n * @returns {Promise<boolean>} Success indicator\n */\nexport async function extractContent(tabId, url) {\n  // Check if the page is injectable before proceeding\n  if (!isInjectablePage(url)) {\n    logger.background.warn(`Cannot extract content from non-injectable URL: ${url}`);\n    await chrome.storage.local.set({ [STORAGE_KEYS.CONTENT_READY]: false, [STORAGE_KEYS.EXTRACTED_CONTENT]: null });\n    return false;\n  }\n\n  const contentType = determineContentType(url);\n  // Use a single content script for all types\n  const scriptFile = 'dist/content-script.bundle.js';\n\n  logger.background.info(`Extracting content from tab ${tabId}, type: ${contentType}`);\n\n  // Always inject the content script\n  const result = await injectContentScript(tabId, scriptFile);\n  if (!result) {\n    logger.background.error(`Failed to inject content script into tab ${tabId}`);\n    return false; // Stop if injection fails\n  }\n\n  // Always reset previous extraction state after successful injection\n  try {\n    await chrome.tabs.sendMessage(tabId, { \n      action: 'resetExtractor'\n    });\n    logger.background.info('Reset command sent to extractor');\n  } catch (error) {\n    // Log error but potentially continue if reset fails, as extraction might still work\n    logger.background.error('Error sending reset command:', error); \n  }\n  \n  // Return promise that resolves when content extraction completes\n  return new Promise((resolve) => {\n    const storageListener = (changes, area) => {\n      if (area === 'local' && changes[STORAGE_KEYS.CONTENT_READY]?.newValue === true) {\n        clearTimeout(timeoutId); // Ensure timeout is cleared on success\n        chrome.storage.onChanged.removeListener(storageListener);\n        resolve(true);\n      }\n    };\n\n    chrome.storage.onChanged.addListener(storageListener);\n\n    // Send extraction command\n    chrome.tabs.sendMessage(tabId, {\n      action: 'extractContent',\n      contentType: contentType\n        });\n\n        // Failsafe timeout\n        const timeoutId = setTimeout(() => {\n          chrome.storage.onChanged.removeListener(storageListener);\n          logger.background.warn(`Extraction timeout for ${contentType}, proceeding anyway`);\n      resolve(false);\n    }, 15000);\n  });\n}\n\n/**\n * Inject content script into tab\n * @param {number} tabId - Tab ID to inject into\n * @param {string} scriptFile - Script file to inject\n * @returns {Promise<boolean>} Success flag\n */\nexport async function injectContentScript(tabId, scriptFile) {\n  try {\n    logger.background.info(`Injecting script: ${scriptFile} into tab: ${tabId}`);\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      files: [scriptFile]\n    });\n    logger.background.info(`Successfully injected script: ${scriptFile} into tab: ${tabId}`);\n    return true;\n  } catch (error) {\n    logger.background.error(`Script injection error for tab ${tabId}:`, error);\n    return false;\n  }\n}\n","// src/background/services/content-processing.js - Content processing\n\nimport { determineContentType, isInjectablePage } from '../../shared/utils/content-utils.js';\nimport { extractContent } from './content-extraction.js';\nimport { openAiPlatformWithContent } from './platform-integration.js';\nimport { resetExtractionState, savePlatformTabInfo } from '../core/state-manager.js';\nimport { processContentViaApi } from '../api/api-coordinator.js';\nimport logger from '../../shared/logger.js';\nimport { STORAGE_KEYS } from '../../shared/constants.js';\nimport ContentFormatter from '../../services/ContentFormatter.js';\n\n/**\n * Process content using web AI interface (non-API path)\n * Used by popup to extract content and send to web UI\n * @param {Object} params - Processing parameters\n * @returns {Promise<Object>} Result information\n */\nexport async function processContent(params) {\n  const { \n    tabId, \n    url, \n    platformId = null,\n    promptContent = null,\n    useApi = false\n  } = params;\n  \n  try {\n    logger.background.info('Starting web UI content processing', {\n      tabId, url, platformId\n    });\n    \n    // If API mode requested, use API path\n    if (useApi) {\n      return await processContentViaApi(params);\n    }\n\n    // Check if page is injectable BEFORE attempting extraction\n    if (!isInjectablePage(url)) {\n      logger.background.warn(`processContent: Page is not injectable (${url}). Skipping extraction.`);\n      return {\n        success: false,\n        error: 'Content extraction not supported on this page.',\n        code: 'EXTRACTION_NOT_SUPPORTED'\n      };\n    }\n    \n    // Check for prompt content\n    if (!promptContent) {\n      return {\n        success: false,\n        error: 'No prompt content provided'\n      };\n    }\n    \n    // 1. Reset previous state\n    await resetExtractionState();\n    \n    // 2. Extract content\n    const contentType = determineContentType(url);\n    logger.background.info(`Content type determined: ${contentType}`);\n    \n    const extractionResult = await extractContent(tabId, url);\n    if (!extractionResult) {\n      logger.background.warn('Content extraction completed with issues');\n    }\n\n    // 3. Get extracted content and check for specific errors\n    const { extractedContent } = await chrome.storage.local.get(STORAGE_KEYS.EXTRACTED_CONTENT);\n    \n    if (!extractedContent) {\n      throw new Error('Failed to extract content');\n    }\n\n    // 4. Format content\n    const formattedContentString = ContentFormatter.formatContent(extractedContent, contentType);\n    \n    // 5. Get platform and open it with content\n    const effectivePlatformId = platformId;\n    \n    const aiPlatformTabId = await openAiPlatformWithContent(effectivePlatformId);\n    \n    if (!aiPlatformTabId) {\n      return {\n        success: false,\n        error: 'Failed to open AI platform tab'\n      };\n    }\n    \n    // Save tab information for later, including the formatted content\n    await savePlatformTabInfo(aiPlatformTabId, effectivePlatformId, promptContent, formattedContentString);\n    \n    return {\n      success: true,\n      aiPlatformTabId,\n      contentType\n    };\n  } catch (error) {\n    logger.background.error('Error in processContent:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error occurred'\n    };\n  }\n}\n\n\n/**\n * Handle process content request from message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response function\n */\nexport async function handleProcessContentRequest(message, sendResponse) {\n  try {\n    const { tabId, platformId, url, promptContent, useApi } = message;\n    logger.background.info(`Process content request for tab ${tabId}`, {\n      platformId, useApi\n    });\n\n    // Call appropriate processing function based on API flag\n    const result = useApi\n      ? await processContentViaApi(message)\n      : await processContent(message);\n\n    sendResponse(result);\n  } catch (error) {\n    logger.background.error('Error handling process content request:', error);\n    sendResponse({\n      success: false,\n      error: error.message\n    });\n  }\n}\n\n/**\n * Handle API content processing request from message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response function\n */\nexport async function handleProcessContentViaApiRequest(message, sendResponse) {\n  try {\n    const result = await processContentViaApi(message);\n    sendResponse(result);\n  } catch (error) {\n    logger.background.error('Error in API content processing:', error);\n    sendResponse({\n      success: false,\n      error: error.message\n    });\n  }\n}\n","// src/background/services/credential-manager.js - Credential management\n\nimport CredentialManagerService from '../../services/CredentialManager.js';\nimport logger from '../../shared/logger.js';\n\n/**\n * Handle credential operation request\n * @param {Object} message - Message with operation details\n * @param {Function} sendResponse - Response function\n */\nexport async function handleCredentialOperation(message, sendResponse) {\n  try {\n    const { operation, platformId, credentials } = message;\n    \n    switch (operation) {\n      case 'get':\n        const storedCredentials = await CredentialManagerService.getCredentials(platformId);\n        sendResponse({\n          success: true,\n          credentials: storedCredentials\n        });\n        break;\n        \n      case 'store':\n        const storeResult = await CredentialManagerService.storeCredentials(platformId, credentials);\n        sendResponse({\n          success: storeResult\n        });\n        break;\n        \n      case 'remove':\n        const removeResult = await CredentialManagerService.removeCredentials(platformId);\n        sendResponse({\n          success: removeResult\n        });\n        break;\n        \n      case 'validate':\n        const validationResult = await CredentialManagerService.validateCredentials(platformId, credentials);\n        sendResponse({\n          success: true,\n          validationResult\n        });\n        break;\n        \n      default:\n        throw new Error(`Unknown credential operation: ${operation}`);\n    }\n  } catch (error) {\n    logger.background.error('Error in credential operation:', error);\n    sendResponse({\n      success: false,\n      error: error.message\n    });\n  }\n}\n\n/**\n * Verify API credentials exist for a platform\n * @param {string} platformId - Platform identifier\n * @returns {Promise<boolean>} True if valid credentials exist\n */\nexport async function verifyApiCredentials(platformId) {\n  try {\n    logger.background.info(`Verifying API credentials for ${platformId}`);\n    const hasCredentials = await CredentialManagerService.hasCredentials(platformId);\n    \n    if (!hasCredentials) {\n      logger.background.error(`No API credentials found for ${platformId}`);\n      throw new Error(`No API credentials found for ${platformId}`);\n    }\n    \n    return true;\n  } catch (error) {\n    logger.background.error(`Credential verification error: ${error.message}`);\n    throw error;\n  }\n}\n","// src/background/services/platform-integration.js - AI platform interactions\n\nimport { AI_PLATFORMS } from '../../shared/constants.js';\nimport logger from '../../shared/logger.js';\nimport ConfigService from '../../services/ConfigService.js';\n\n/**\n * Get platform content script path\n * @param {string} platformId - Platform identifier\n * @returns {string} Path to content script\n */\nexport function getPlatformContentScript() {\n  return 'dist/platform-content.bundle.js';\n}\n\n/**\n * Open AI platform with extracted content\n * @param {string} contentType - Content type\n * @param {string} promptId - Prompt ID\n * @param {string} platformId - Platform ID\n * @returns {Promise<number|null>} Tab ID or null\n */\nexport async function openAiPlatformWithContent(platformId) {\n  try {\n    // Prepare platform and prompt information\n    const effectivePlatformId = platformId;\n    if (!effectivePlatformId) {\n        throw new Error('Platform ID must be provided to openAiPlatformWithContent');\n    }\n\n    // Get display config from ConfigService\n    const platformDisplayInfo = await ConfigService.getPlatformDisplayConfig(effectivePlatformId);\n\n    if (!platformDisplayInfo || !platformDisplayInfo.url || !platformDisplayInfo.name) {\n      throw new Error(`Could not load display config (url, name) for platform: ${effectivePlatformId}`);\n    }\n\n    // Open platform in a new tab using display info\n    const platformUrl = platformDisplayInfo.url;\n    const platformName = platformDisplayInfo.name;\n    logger.background.info(`Opening ${platformName} at URL: ${platformUrl}`);\n    const newTab = await chrome.tabs.create({ url: platformUrl });\n\n    if (!newTab || !newTab.id) {\n      throw new Error(`Failed to create ${platformName} tab or get tab ID`);\n    }\n\n    logger.background.info(`${platformName} tab created with ID: ${newTab.id}`);\n    \n    return newTab.id;\n  } catch (error) {\n    logger.background.error('Error opening AI platform:', error);\n    return null;\n  }\n}\n\n/**\n * Check if a tab is a platform tab\n * @param {number} tabId - Tab ID to check\n * @param {string} url - Tab URL\n * @param {string} platformId - Platform ID\n * @returns {boolean} Whether this is a platform tab\n */\nexport function isPlatformTab(tabId, url, platformId) {\n  let isPlatformTab = false;\n\n  if (platformId === AI_PLATFORMS.CLAUDE && url.includes('claude.ai')) {\n    isPlatformTab = true;\n  } else if (platformId === AI_PLATFORMS.CHATGPT && url.includes('chatgpt.com')) {\n    isPlatformTab = true;\n  } else if (platformId === AI_PLATFORMS.DEEPSEEK && url.includes('chat.deepseek.com')) {\n    isPlatformTab = true;\n  } else if (platformId === AI_PLATFORMS.MISTRAL && url.includes('chat.mistral.ai')) {\n    isPlatformTab = true;\n  } else if (platformId === AI_PLATFORMS.GEMINI && url.includes('gemini.google.com')) {\n    isPlatformTab = true;\n  } else if (platformId === AI_PLATFORMS.GROK && url.includes('grok.com')) {\n    isPlatformTab = true;\n  }\n\n  return isPlatformTab;\n}","// src/background/services/sidebar-manager.js - Tab-specific native side panel management\n\nimport SidebarStateManager from '../../services/SidebarStateManager.js';\nimport logger from '../../shared/logger.js';\n\n/**\n * Toggle native side panel visibility for a specific tab.\n * @param {Object} message - Message object containing optional `tabId` and `visible` properties.\n * @param {Object} sender - Message sender, potentially containing `sender.tab.id`.\n * @param {Function} sendResponse - Function to send the response back.\n */\nexport async function toggleNativeSidePanel(message, sender, sendResponse) {\n  let targetTabId;\n  let newState; // To store the final state (true for open, false for closed)\n  try {\n    logger.background.info('Handling native side panel toggle request (Refactored)');\n\n    // Determine the target tab ID\n    const explicitTabId = message?.tabId || sender?.tab?.id;\n    if (explicitTabId) {\n      targetTabId = explicitTabId;\n    } else {\n      const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (!activeTab?.id) {\n        throw new Error('No active tab found to target for side panel toggle.');\n      }\n      targetTabId = activeTab.id;\n    }\n    logger.background.info(`Targeting tab ${targetTabId} for side panel operation.`);\n\n    // Read the current *intended* state from storage\n    const currentState = await SidebarStateManager.getSidebarVisibilityForTab(targetTabId);\n    logger.background.info(`Current stored visibility for tab ${targetTabId}: ${currentState}`);\n\n    // Determine the new state and perform actions\n    if (currentState === false) {\n      // Current state is closed, so we intend to open (enable) it\n      newState = true;\n      logger.background.info(`Action: Enable side panel for tab ${targetTabId}`);\n      await SidebarStateManager.setSidebarVisibilityForTab(targetTabId, true);\n      await chrome.sidePanel.setOptions({\n        tabId: targetTabId,\n        path: `sidepanel.html?tabId=${targetTabId}`, // Pass tabId via URL\n        enabled: true\n      });\n      logger.background.info(`Side panel enabled and path set for tab ${targetTabId}.`);\n    } else {\n      // Current state is open, so we intend to close (disable) it\n      newState = false;\n      logger.background.info(`Action: Disable side panel for tab ${targetTabId}`);\n      await SidebarStateManager.setSidebarVisibilityForTab(targetTabId, false);\n      await chrome.sidePanel.setOptions({\n        tabId: targetTabId,\n        enabled: false\n      });\n      logger.background.info(`Side panel disabled for tab ${targetTabId}.`);\n    }\n\n    sendResponse({\n      success: true,\n      visible: newState, // Send back the new intended state\n      tabId: targetTabId,\n      message: `Side panel state updated for tab ${targetTabId}. Intended visibility: ${newState}.`\n    });\n\n  } catch (error) {\n    logger.background.error(`Error handling native side panel toggle for tab ${targetTabId || 'unknown'}:`, error);\n    // If an error occurred, the actual panel state might not match the intended state.\n    // We send back the intended newState if determined, otherwise report failure.\n    sendResponse({\n      success: false,\n      error: error.message,\n      tabId: targetTabId,\n      visible: newState // Include intended state if available, even on error\n    });\n  }\n}\n\n\n/**\n * Handles the 'toggleNativeSidePanelAction' message request.\n * @param {object} message - The message object.\n * @param {chrome.runtime.MessageSender} sender - The sender of the message.\n * @param {function} sendResponse - Function to call to send the response.\n * @returns {boolean} - True to indicate an asynchronous response.\n */\nexport function handleToggleNativeSidePanelAction(message, sender, sendResponse) {\n  logger.background.info('Received toggleNativeSidePanelAction request via message router');\n  // Call the actual function which handles the logic and response\n  toggleNativeSidePanel(message, sender, sendResponse);\n  // toggleNativeSidePanel is async and handles sendResponse itself\n  return true; // Keep channel open for async response\n}\n\n\n/**\n * Get sidebar state for specific tab\n * @param {Object} message - Message object\n * @param {Object} sender - Message sender\n * @param {Function} sendResponse - Response function\n */\nexport async function getSidebarState(message, sender, sendResponse) {\n  try {\n    // Get target tab ID (same logic as toggle)\n    const tabId = message.tabId || (sender.tab && sender.tab.id);\n    let targetTabId;\n    \n    if (!tabId) {\n      // Get active tab if no tab ID specified\n      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n      const activeTab = tabs[0];\n      \n      if (!activeTab || !activeTab.id) {\n        throw new Error('No active tab found');\n      }\n      \n      targetTabId = activeTab.id;\n    } else {\n      targetTabId = tabId;\n    }\n    \n    const state = await SidebarStateManager.getSidebarState(targetTabId);\n    \n    sendResponse({\n      success: true,\n      state,\n      tabId: targetTabId\n    });\n  } catch (error) {\n    logger.background.error('Error handling tab-specific sidebar state query:', error);\n    sendResponse({ success: false, error: error.message });\n  }\n}\n","// src/background/services/theme-service.js - Theme synchronization services\n\nimport { STORAGE_KEYS } from '../../shared/constants.js';\nimport logger from '../../shared/logger.js';\n\n/**\n * Handle theme operation requests\n * @param {Object} message - Message with operation details\n * @param {Function} sendResponse - Response function\n */\nexport async function handleThemeOperation(message, sendResponse) {\n  try {\n    const { action, theme } = message;\n    \n    switch (action) {\n      case 'getTheme':\n        const result = await chrome.storage.sync.get(STORAGE_KEYS.THEME_PREFERENCE);\n        sendResponse({\n          success: true,\n          theme: result[STORAGE_KEYS.THEME_PREFERENCE] || 'light'\n        });\n        break;\n        \n      case 'setTheme':\n        if (!theme) {\n          throw new Error('Theme value is required for setTheme operation');\n        }\n        \n        await chrome.storage.sync.set({ [STORAGE_KEYS.THEME_PREFERENCE]: theme });\n        \n        // Notify only tabs with active sidebars about theme change\n        const sidebarStateResult = await chrome.storage.local.get(STORAGE_KEYS.TAB_SIDEBAR_STATES);\n        const sidebarStates = sidebarStateResult[STORAGE_KEYS.TAB_SIDEBAR_STATES] || {};\n        const targetTabIds = [];\n\n        for (const [tabIdStr, isVisible] of Object.entries(sidebarStates)) {\n          if (isVisible) {\n            const tabId = parseInt(tabIdStr, 10);\n            // Basic check if parsing was successful (tab IDs should always be numbers)\n            if (!isNaN(tabId)) {\n              targetTabIds.push(tabId);\n            } else {\n              logger.background.warn(`Invalid tab ID found in sidebar states: ${tabIdStr}`);\n            }\n          }\n        }\n\n        for (const tabId of targetTabIds) {\n          try {\n            await chrome.tabs.sendMessage(tabId, { action: 'themeUpdated', theme });\n          } catch (error) {\n            if (error.message && (error.message.includes('Could not establish connection') || error.message.includes('Receiving end does not exist'))) {\n              logger.background.warn(`Could not send theme update to active sidebar tab ${tabId}: Receiving end does not exist.`);\n            } else {\n              logger.background.error(`Failed to send theme update to active sidebar tab ${tabId}:`, error);\n            }\n          }\n        }\n        \n        sendResponse({\n          success: true,\n          theme\n        });\n        break;\n        \n      default:\n        throw new Error(`Unknown theme operation: ${action}`);\n    }\n  } catch (error) {\n    logger.background.error('Error in theme operation:', error);\n    sendResponse({\n      success: false,\n      error: error.message\n    });\n  }\n}\n","// src/services/ApiServiceManager.js\n\nconst ApiFactory = require('../api/api-factory');\nconst CredentialManager = require('./CredentialManager');\nconst ModelParameterService = require('./ModelParameterService');\nconst logger = require('../shared/logger.js').service;\nconst ConfigService = require('./ConfigService');\n\n/**\n * Centralized manager for API service operations\n */\nclass ApiServiceManager {\n  constructor() {\n    this.credentialManager = CredentialManager;\n    this.modelParameterService = ModelParameterService;\n  }\n\n  /**\n   * Process content through API with unified request configuration\n   * @param {string} platformId - Platform identifier\n   * @param {Object} requestConfig - Unified request configuration object\n   * @param {Object} requestConfig.contentData - Extracted content data\n   * @param {string} requestConfig.prompt - Formatted prompt\n   * @param {string} [requestConfig.model] - Optional model override\n   * @param {Array} [requestConfig.conversationHistory] - Optional conversation history\n   * @param {string} requestConfig.prompt - User prompt\n   * @param {Object} requestConfig.resolvedParams - Resolved model parameters (model, temp, etc.)\n   * @param {string|null} requestConfig.formattedContent - Formatted content string or null\n   * @param {Array} [requestConfig.conversationHistory] - Optional conversation history\n   * @param {boolean} requestConfig.streaming - Whether to use streaming (should always be true here)\n   * @param {Function} requestConfig.onChunk - Callback for streaming chunks\n   * @returns {Promise<Object>} API response\n   */\n  async processWithUnifiedConfig(platformId, requestConfig) {\n    try {\n\n      logger.info(`Processing content through ${platformId} API with unified config:`, {\n        hasStreaming: !!requestConfig.streaming,\n        hasHistory: Array.isArray(requestConfig.resolvedParams?.conversationHistory) && \n           requestConfig.resolvedParams?.conversationHistory.length > 0,\n        model: requestConfig.resolvedParams?.model || 'N/A',\n        tabId: requestConfig.resolvedParams?.tabId || 'N/A',\n        hasFormattedContent: requestConfig.formattedContent !== null && requestConfig.formattedContent !== undefined\n      });\n\n      // Ensure we have the necessary configuration\n      if (!requestConfig || !requestConfig.resolvedParams) {\n        throw new Error('Request configuration with resolvedParams is required');\n      }\n\n      // Get credentials\n      const credentials = await this.credentialManager.getCredentials(platformId);\n      if (!credentials) {\n        throw new Error(`No API credentials found for ${platformId}`);\n      }\n\n      // Create API service\n      const apiService = ApiFactory.createApiService(platformId);\n      if (!apiService) {\n        throw new Error(`API service not available for ${platformId}`);\n      }\n\n      // Initialize API service\n      await apiService.initialize(credentials);\n\n      // Process the request using the unified interface\n      return await apiService.processRequest(requestConfig);\n    } catch (error) {\n      logger.error(`Error processing content through ${platformId} API:`, error);\n      return {\n        success: false,\n        error: error.message,\n        platformId,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * Verify API credentials with lightweight validation\n   * @param {string} platformId - Platform identifier\n   * @param {Object} [credentials] - Optional credentials (if not provided, stored credentials will be used)\n   * @returns {Promise<boolean>} Validation result\n   */\n  async validateCredentials(platformId, credentials = null) {\n    try {\n      // Get credentials if not provided\n      const credentialsToUse = credentials || await this.credentialManager.getCredentials(platformId);\n\n      if (!credentialsToUse) {\n        logger.warn(`No credentials available for ${platformId}`);\n        return false;\n      }\n\n      // Create API service\n      const apiService = ApiFactory.createApiService(platformId);\n      if (!apiService) {\n        throw new Error(`API service not available for ${platformId}`);\n      }\n\n      // Initialize with credentials\n      await apiService.initialize(credentialsToUse);\n\n      // Use lightweight validation method\n      return await apiService.validateCredentials();\n    } catch (error) {\n      logger.error(`Error validating credentials for ${platformId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if API mode is available for a platform\n   * @param {string} platformId - Platform identifier\n   * @returns {Promise<boolean>} True if API mode is available\n   */\n  async isApiModeAvailable(platformId) {\n    try {\n      const settings = await this.getApiSettings(platformId);\n      const hasCredentials = await this.credentialManager.hasCredentials(platformId);\n\n      return !!(settings && hasCredentials);\n    } catch (error) {\n      logger.error(`Error checking API mode availability for ${platformId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get available models for a platform\n   * @param {string} platformId - Platform identifier\n   * @returns {Promise<Array<Object>|null>} Available models\n   */\n  async getAvailableModels(platformId) {\n    try {\n      const settings = await ConfigService.getPlatformApiConfig(platformId);\n      return settings?.models || null;\n    } catch (error) {\n      logger.error(`Error getting available models for ${platformId}:`, error);\n      return null;\n    }\n  }\n}\n\n// Export singleton instance\nconst apiServiceManager = new ApiServiceManager();\nmodule.exports = apiServiceManager;\n","// src/services/ConfigService.js\nconst logger = require('../shared/logger.js'); // Changed from import to require\n\nlet cachedApiConfig = null;\nlet cachedDisplayConfig = null;\n\n/**\n * Internal helper to load configuration with caching.\n * @param {string} urlPath - The path relative to the extension root (e.g., 'platform-api-config.json').\n * @param {object | null} cacheRef - Reference to the module-level cache variable.\n * @returns {Promise<object>} - The loaded configuration object.\n */\nasync function _loadConfig(urlPath, cacheRef) {\n  if (cacheRef) {\n    logger.service.info(`ConfigService: Cache hit for ${urlPath}`);\n    return cacheRef;\n  }\n\n  logger.service.info(`ConfigService: Loading configuration from ${urlPath}...`);\n  try {\n    const response = await fetch(chrome.runtime.getURL(urlPath));\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${urlPath}: ${response.statusText}`);\n    }\n    const config = await response.json();\n    // Update the cache indirectly by returning the loaded config,\n    // the caller will assign it to the cache variable.\n    logger.service.info(`ConfigService: Successfully loaded ${urlPath}.`);\n    return config;\n  } catch (error) {\n    logger.service.error(`ConfigService: Error loading configuration from ${urlPath}:`, error);\n    throw error; // Re-throw to be handled by the caller\n  }\n}\n\n/**\n * Gets the entire API configuration object, loading and caching if necessary.\n * @returns {Promise<object>} The API configuration object.\n */\nasync function getApiConfig() {\n  if (!cachedApiConfig) {\n    cachedApiConfig = await _loadConfig('platform-api-config.json', cachedApiConfig);\n  }\n  return cachedApiConfig;\n}\n\n/**\n * Gets the entire display configuration object, loading and caching if necessary.\n * @returns {Promise<object>} The display configuration object.\n */\nasync function getDisplayConfig() {\n  if (!cachedDisplayConfig) {\n    cachedDisplayConfig = await _loadConfig('platform-display-config.json', cachedDisplayConfig);\n  }\n  return cachedDisplayConfig;\n}\n\n/**\n * Gets the API configuration for a specific platform.\n * @param {string} platformId - The ID of the platform.\n * @returns {Promise<object|null>} The API configuration for the platform, or null if not found.\n */\nasync function getPlatformApiConfig(platformId) {\n  try {\n    const config = await getApiConfig();\n    return config?.aiPlatforms?.[platformId] || null;\n  } catch (error) {\n    logger.service.error(`ConfigService: Error getting API config for platform ${platformId}:`, error);\n    return null;\n  }\n}\n\n/**\n * Gets the display configuration for a specific platform.\n * @param {string} platformId - The ID of the platform.\n * @returns {Promise<object|null>} The display configuration for the platform, or null if not found.\n */\nasync function getPlatformDisplayConfig(platformId) {\n  try {\n    const config = await getDisplayConfig();\n    return config?.aiPlatforms?.[platformId] || null;\n  } catch (error) {\n    logger.service.error(`ConfigService: Error getting display config for platform ${platformId}:`, error);\n    return null;\n  }\n}\n\n/**\n * Gets a combined list of all platform configurations (display + API).\n * Useful for UI components needing comprehensive platform info.\n * @returns {Promise<Array<object>>} A list of combined platform configuration objects.\n */\nasync function getAllPlatformConfigs() {\n  try {\n    const [displayConfig, apiConfigData] = await Promise.all([\n      getDisplayConfig(),\n      getApiConfig()\n    ]);\n\n    if (!displayConfig?.aiPlatforms || !apiConfigData?.aiPlatforms) {\n      throw new Error('AI platforms configuration not found in one or both files');\n    }\n\n    const platformList = Object.keys(displayConfig.aiPlatforms).map((id) => {\n      const displayInfo = displayConfig.aiPlatforms[id];\n      const apiInfo = apiConfigData.aiPlatforms[id];\n\n      if (!displayInfo || !apiInfo) {\n        logger.service.warn(`ConfigService: Missing config for platform ID: ${id} during getAllPlatformConfigs`);\n        return null; // Skip if data is incomplete\n      }\n\n      return {\n        id,\n        name: displayInfo.name,\n        url: displayInfo.url,\n        iconUrl: chrome.runtime.getURL(displayInfo.icon),\n        docApiLink: displayInfo.docApiLink || '#',\n        modelApiLink: displayInfo.modelApiLink || '#',\n        consoleApiLink: displayInfo.consoleApiLink || '#',\n        keyApiLink: displayInfo.keyApiLink || '#',\n        apiConfig: apiInfo // Attach the whole API config object\n      };\n    }).filter(p => p !== null); // Filter out any null entries\n\n    return platformList;\n  } catch (error) {\n    logger.service.error('ConfigService: Error getting all platform configs:', error);\n    return []; // Return empty array on error\n  }\n}\n\n// Optional: Add a function to clear the cache if needed for hot-reloading during development\nfunction clearConfigCache() {\n  cachedApiConfig = null;\n  cachedDisplayConfig = null;\n  logger.service.info('ConfigService: Cache cleared.');\n}\n\n// Define the ConfigService object with all exported functions\nconst ConfigService = {\n  getApiConfig,\n  getDisplayConfig,\n  getPlatformApiConfig,\n  getPlatformDisplayConfig,\n  getAllPlatformConfigs,\n  clearConfigCache\n};\n\nmodule.exports = ConfigService;","// src/services/ContentFormatter.js\nconst logger = require('../shared/logger.js').service;\n\nclass ContentFormatter {\n  /**\n   * Format content based on content type\n   * @param {Object} contentData - The extracted content data\n   * @param {string} contentType - The type of content (e.g., 'youtube', 'reddit', 'general', 'pdf')\n   * @returns {string} Formatted content\n   */\n  static formatContent(contentData, contentType) {\n    if (!contentData) {\n      logger.error('No content data available for formatting');\n      return 'No content data available';\n    }\n\n    logger.info(`Formatting content of type: ${contentType}`);\n\n    let formatted = '';\n    switch (contentType) {\n      case 'youtube':\n        formatted = this._formatYouTubeData(contentData);\n        break;\n      case 'reddit':\n        formatted = this._formatRedditData(contentData);\n        break;\n      case 'general':\n        formatted = this._formatGeneralData(contentData);\n        break;\n      case 'pdf':\n        formatted = this._formatPdfData(contentData);\n        break;\n      default:\n        logger.warn(`Unknown content type '${contentType}', using JSON stringify`);\n        try {\n          formatted = `Content Type: ${contentType}\\nData: ${JSON.stringify(contentData, null, 2)}`;\n        } catch (e) {\n          logger.error('Failed to stringify unknown content data:', e);\n          formatted = `Content Type: ${contentType}\\nData: [Could not stringify]`;\n        }\n    }\n\n    return formatted;\n  }\n\n  /**\n   * Format YouTube video data\n   * @private\n   * @param {Object} data - YouTube video data\n   * @returns {string} Formatted YouTube data\n   */\n  static _formatYouTubeData(data) {\n    const title = data.videoTitle || 'No title available';\n    const channel = data.channelName || 'Unknown channel';\n    const description = data.videoDescription || 'No description available';\n    const transcript = data.transcript || 'No transcript available';\n\n    // Format comments with likes\n    let commentsText = '';\n    if (data.comments && Array.isArray(data.comments) && data.comments.length > 0) {\n      commentsText = `## COMMENTS\\n`;\n      data.comments.forEach((comment, index) => {\n        commentsText += `${index + 1}. User: ${comment.author || 'Anonymous'} (${comment.likes || '0'} likes)\\n  \"${comment.text || ''}\"\\n`;\n      });\n    }\n\n    return `## VIDEO METADATA\\n  - Title: ${title}\\n  - Channel: ${channel}\\n  - URL: https://www.youtube.com/watch?v=${data.videoId || ''}\\n## DESCRIPTION\\n${description}\\n## TRANSCRIPT\\n${transcript}\\n${commentsText}`;\n  }\n\n  /**\n   * Format Reddit post data\n   * @private\n   * @param {Object} data - Reddit post data\n   * @returns {string} Formatted Reddit data\n   */\n  static _formatRedditData(data) {\n    const title = data.postTitle || 'No title available';\n    const content = data.postContent || 'No content available';\n    const author = data.postAuthor || 'Unknown author';\n    const postUrl = data.postUrl || '';\n    const subreddit = data.subreddit || 'Unknown subreddit';\n\n    let formattedText = `## POST METADATA\\n  - Title: ${title}\\n  - Author: ${author}\\n  - Subreddit: ${subreddit}\\n  - URL: ${postUrl}\\n## POST CONTENT\\n${content}\\n`;\n\n    // Format comments with links\n    if (data.comments && Array.isArray(data.comments) && data.comments.length > 0) {\n      formattedText += `## COMMENTS\\n`;\n\n      data.comments.forEach((comment, index) => {\n        formattedText += `${index + 1}. u/${comment.author || 'Anonymous'} (${comment.popularity || '0'} points) [(link)](${comment.permalink || postUrl})\\n  \"${comment.content || ''}\"\\n`;\n      });\n    }\n\n    return formattedText;\n  }\n\n  /**\n   * Format general web page data\n   * @private\n   * @param {Object} data - Web page data\n   * @returns {string} Formatted web page data\n   */\n  static _formatGeneralData(data) {\n    const title = data.pageTitle || 'No title available';\n    const url = data.pageUrl || 'Unknown URL';\n    const content = data.content || 'No content available';\n    const author = data.pageAuthor || null;\n    const description = data.pageDescription || null;\n\n    let metadataText = `## PAGE METADATA\\n  - Title: ${title}\\n  - URL: ${url}`;\n\n    if (author) {\n      metadataText += `\\n  - Author: ${author}`;\n    }\n\n    if (description) {\n      metadataText += `\\n  - Description: ${description}`;\n    }\n\n    return `${metadataText}\\n## PAGE CONTENT\\n${content}`;\n  }\n\n  /**\n   * Format PDF document data\n   * @private\n   * @param {Object} data - PDF document data\n   * @returns {string} Formatted PDF data\n   */\n  static _formatPdfData(data) {\n    const title = data.pdfTitle || 'Untitled PDF';\n    const url = data.pdfUrl || 'Unknown URL';\n    const content = data.content || 'No content available';\n    const pageCount = data.pageCount || 'Unknown';\n    const metadata = data.metadata || {};\n\n    // Format metadata section\n    let metadataText = `## PDF METADATA\\n  - Title: ${title}\\n  - Pages: ${pageCount}\\n  - URL: ${url}`;\n\n    if (metadata.author) {\n      metadataText += `\\n  - Author: ${metadata.author}`;\n    }\n\n    if (metadata.creationDate) {\n      metadataText += `\\n  - Created: ${metadata.creationDate}`;\n    }\n\n    if (data.ocrRequired) {\n      metadataText += `\\n  - Note: This PDF may require OCR as text extraction was limited.`;\n    }\n\n    // Format and clean up the content\n    let formattedContent = content;\n\n    // Remove JSON artifacts if present\n    if (typeof formattedContent === 'string' && formattedContent.includes('{\"content\":\"')) {\n      try {\n        const contentObj = JSON.parse(formattedContent);\n        formattedContent = contentObj.content || formattedContent;\n      } catch (e) {\n        // If parsing fails, keep the original content\n        logger.warn('Failed to parse JSON in PDF content');\n      }\n    }\n\n    // Clean up page markers to make them more readable\n    if (typeof formattedContent === 'string') {\n        formattedContent = formattedContent\n          .replace(/--- Page (\\d+) ---\\n\\n/g, '\\n\\n## PAGE $1\\n') // Corrected regex\n          .replace(/\\n{3,}/g, '\\n\\n')  // Reduce multiple line breaks\n          .trim();\n    } else {\n        logger.warn('PDF content is not a string, skipping cleanup.');\n        formattedContent = String(formattedContent); // Ensure it's a string\n    }\n\n\n    return `${metadataText}\\n\\n## PDF CONTENT\\n${formattedContent}`;\n  }\n}\n\nmodule.exports = ContentFormatter;\n","// src/services/CredentialManager.js\nconst { STORAGE_KEYS } = require('../shared/constants');\nconst logger = require('../shared/logger.js').service;\n\n/**\n * Service for secure API credential management\n */\nclass CredentialManager {\n  constructor() {\n    this.STORAGE_KEY = STORAGE_KEYS.API_CREDENTIALS;\n    this.logger = logger;\n  }\n  \n  /**\n   * Get stored credentials for a platform\n   * @param {string} platformId - Platform identifier\n   * @returns {Promise<Object|null>} Credentials or null if not found\n   */\n  async getCredentials(platformId) {\n    try {\n      this.logger.info(`Getting credentials for ${platformId}`);\n      const result = await chrome.storage.local.get(this.STORAGE_KEY);\n      const credentials = result[this.STORAGE_KEY] || {};\n      return credentials[platformId] || null;\n    } catch (error) {\n      this.logger.error('Error retrieving credentials:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Store credentials for a platform\n   * @param {string} platformId - Platform identifier\n   * @param {Object} credentials - Platform credentials (apiKey, etc.)\n   * @returns {Promise<boolean>} Success indicator\n   */\n  async storeCredentials(platformId, credentials) {\n    try {\n      this.logger.info(`Storing credentials for ${platformId}`);\n      const result = await chrome.storage.local.get(this.STORAGE_KEY);\n      const allCredentials = result[this.STORAGE_KEY] || {};\n      \n      // Update credentials for this platform\n      allCredentials[platformId] = credentials;\n      \n      await chrome.storage.local.set({ [this.STORAGE_KEY]: allCredentials });\n      return true;\n    } catch (error) {\n      this.logger.error('Error storing credentials:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Remove credentials for a platform\n   * @param {string} platformId - Platform identifier\n   * @returns {Promise<boolean>} Success indicator\n   */\n  async removeCredentials(platformId) {\n    try {\n      this.logger.info(`Removing credentials for ${platformId}`);\n      const result = await chrome.storage.local.get(this.STORAGE_KEY);\n      const allCredentials = result[this.STORAGE_KEY] || {};\n      \n      if (allCredentials[platformId]) {\n        delete allCredentials[platformId];\n        await chrome.storage.local.set({ [this.STORAGE_KEY]: allCredentials });\n      }\n      \n      return true;\n    } catch (error) {\n      this.logger.error('Error removing credentials:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Check if credentials exist for a platform\n   * @param {string} platformId - Platform identifier\n   * @returns {Promise<boolean>} True if credentials exist\n   */\n  async hasCredentials(platformId) {\n    const credentials = await this.getCredentials(platformId);\n    return !!credentials;\n  }\n  \n  /**\n   * Validate credentials for a platform by making a test API call\n   * @param {string} platformId - Platform identifier\n   * @param {Object} credentials - Credentials to validate\n   * @returns {Promise<{isValid: boolean, message: string}>} Validation result\n   */\n  async validateCredentials(platformId, credentials) {\n    try {\n      this.logger.info(`Validating credentials for ${platformId}`);\n      \n      const ApiFactory = require('../api/api-factory');\n      const apiService = ApiFactory.createApiService(platformId);\n      \n      if (!apiService) {\n        throw new Error(`No API service available for ${platformId}`);\n      }\n      \n      await apiService.initialize(credentials);\n      const isValid = await apiService.validateCredentials();\n      \n      return {\n        isValid,\n        message: isValid ? 'Credentials validated successfully' : 'Invalid credentials'\n      };\n    } catch (error) {\n      this.logger.error('Validation error:', error);\n      return {\n        isValid: false,\n        message: `Validation error: ${error.message}`\n      };\n    }\n  }\n}\n\nconst credentialManager = new CredentialManager();\nmodule.exports = credentialManager;","// src/services/ModelParameterService.js\nconst { STORAGE_KEYS, INTERFACE_SOURCES } = require('../shared/constants');\nconst logger = require('../shared/logger.js').service;\nconst ConfigService = require('./ConfigService');\n\n/**\n * Service for managing model-specific parameters\n */\nclass ModelParameterService {\n  constructor() {\n    this.cachedConfig = null;\n  }\n\n  /**\n   * Centralized model resolution method with clear priority hierarchy\n   * @param {string} platformId - Platform ID\n   * @param {Object} options - Additional options\n   * @param {number} [options.tabId] - Tab ID for tab-specific preferences\n   * @param {string} [options.source] - Interface source (popup or sidebar)\n   * @returns {Promise<string>} Resolved model ID\n   */\n  async resolveModel(platformId, options = {}) {\n    const { tabId, source } = options;\n    let modelId = null;\n\n    // 1. Try tab-specific model preference (highest priority)\n    if (tabId) {\n      try {\n        const tabPrefs = await chrome.storage.local.get(STORAGE_KEYS.TAB_MODEL_PREFERENCES);\n        const tabModels = tabPrefs[STORAGE_KEYS.TAB_MODEL_PREFERENCES] || {};\n\n        if (tabModels[tabId] && tabModels[tabId][platformId]) {\n          modelId = tabModels[tabId][platformId];\n          logger.info(`Using tab-specific model for ${platformId}: ${modelId}`);\n          return modelId;\n        }\n      } catch (error) {\n        logger.error('Error getting tab-specific model:', error);\n      }\n    }\n\n    // 2. Try source-specific global preference (Sidebar only)\n    if (source === INTERFACE_SOURCES.SIDEBAR) {\n      const storageKey = STORAGE_KEYS.SIDEBAR_MODEL;\n\n      try {\n        const sourcePrefs = await chrome.storage.sync.get(storageKey);\n        const sourcePref = sourcePrefs[storageKey] || {};\n\n        if (sourcePref[platformId]) {\n          modelId = sourcePref[platformId];\n          logger.info(`Using ${source} model preference for ${platformId}: ${modelId}`);\n          return modelId;\n        }\n      } catch (error) {\n        logger.error(`Error getting ${source} model preference:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get model configuration for a specific model\n   * @param {string} platformId - Platform ID\n   * @param {string} modelIdOrObject - Model ID or object containing model ID\n   * @returns {Promise<Object|null>} Model configuration or null if not found\n   */\n  async getModelConfig(platformId, modelIdOrObject) {\n    const config = await ConfigService.getApiConfig();\n\n    // Access models directly under the platform ID in the API config\n    if (!config?.aiPlatforms?.[platformId]?.models) return null;\n\n    // Normalize input - handle both string IDs and model objects\n    const modelId = typeof modelIdOrObject === 'object' && modelIdOrObject !== null\n      ? modelIdOrObject.id || modelIdOrObject.model || String(modelIdOrObject)\n      : modelIdOrObject;\n\n    logger.info(`Resolving model config for: ${platformId}/${modelId}`);\n\n    const platformApiConfig = config.aiPlatforms[platformId];\n\n    // Find model in array of objects within the API config\n    return platformApiConfig.models.find(model => model.id === modelId) || null;\n  }\n\n  /**\n   * Get user-defined model settings\n   * @param {string} platformId - Platform ID\n   * @param {string} modelId - Model ID\n   * @returns {Promise<Object>} User settings for the model\n   */\n  async getUserModelSettings(platformId, modelId) {\n    try {\n      const result = await chrome.storage.sync.get(STORAGE_KEYS.API_ADVANCED_SETTINGS);\n      const advancedSettings = result[STORAGE_KEYS.API_ADVANCED_SETTINGS] || {};\n\n      // Get platform settings\n      const platformSettings = advancedSettings[platformId] || {};\n\n      // First try model-specific settings, then fall back to default settings\n      const modelSettings =\n        (platformSettings.models && platformSettings.models[modelId]) ||\n        platformSettings.default ||\n        {};\n\n      logger.info(`User settings retrieved for ${platformId}/${modelId}:`, modelSettings);\n\n      return modelSettings;\n    } catch (error) {\n      logger.error('Error getting user model settings:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Save model preference for a specific tab\n   * @param {number} tabId - Tab ID\n   * @param {string} platformId - Platform ID\n   * @param {string} modelId - Model ID to save\n   * @returns {Promise<boolean>} Success indicator\n   */\n  async saveTabModelPreference(tabId, platformId, modelId) {\n    try {\n      // Get current tab preferences\n      const tabPrefs = await chrome.storage.local.get(STORAGE_KEYS.TAB_MODEL_PREFERENCES);\n      const tabModels = tabPrefs[STORAGE_KEYS.TAB_MODEL_PREFERENCES] || {};\n\n      // Initialize tab entry if needed\n      if (!tabModels[tabId]) {\n        tabModels[tabId] = {};\n      }\n\n      // Save model preference\n      tabModels[tabId][platformId] = modelId;\n\n      // Store updated preferences\n      await chrome.storage.local.set({\n        [STORAGE_KEYS.TAB_MODEL_PREFERENCES]: tabModels,\n      });\n\n      logger.info(`Saved tab model preference: Tab ${tabId}, Platform ${platformId}, Model ${modelId}`);\n      return true;\n    } catch (error) {\n      logger.error('Error saving tab model preference:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Save global model preference for a source\n   * @param {string} source - Interface source (popup or sidebar)\n   * @param {string} platformId - Platform ID\n   * @param {string} modelId - Model ID to save\n   * @returns {Promise<boolean>} Success indicator\n   */\n  async saveSourceModelPreference(source, platformId, modelId) {\n    // Only save for sidebar, popup uses last selected via settings or default\n    if (source !== INTERFACE_SOURCES.SIDEBAR) {\n        logger.warn(`Not saving model preference for non-sidebar source: ${source}`);\n        return false;\n    }\n\n    try {\n      const storageKey = STORAGE_KEYS.SIDEBAR_MODEL;\n\n      // Get current preferences\n      const prefs = await chrome.storage.sync.get(storageKey);\n      const modelPrefs = prefs[storageKey] || {};\n\n      // Update preference\n      modelPrefs[platformId] = modelId;\n\n      // Save updated preferences\n      await chrome.storage.sync.set({ [storageKey]: modelPrefs });\n\n      logger.info(`Saved ${source} model preference: Platform ${platformId}, Model ${modelId}`);\n      return true;\n    } catch (error) {\n      logger.error(`Error saving ${source} model preference:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Resolve parameters for a specific model, combining defaults and user settings\n   * @param {string} platformId - Platform ID\n   * @param {string} modelId - The specific model ID to use.\n   * @param {Object} options - Additional options\n   * @param {number} [options.tabId] - Tab ID for context (e.g., token tracking)\n   * @param {string} [options.source] - Interface source (popup or sidebar)\n   * @param {Array} [options.conversationHistory] - Optional conversation history for context\n   * @returns {Promise<Object>} Resolved parameters object for API calls\n   */\n  async resolveParameters(platformId, modelId, options = {}) {\n    // Add immediate check for modelId\n    if (!modelId) {\n      throw new Error('Model ID must be provided to resolveParameters');\n    }\n\n    try {\n      const { tabId, source, conversationHistory } = options;\n      logger.info(`Resolving parameters for ${platformId}/${modelId}, Source: ${source || 'N/A'}, Tab: ${tabId || 'N/A'}`);\n\n      // Get the full platform config first\n      const config = await ConfigService.getApiConfig();\n      const platformApiConfig = config?.aiPlatforms?.[platformId];\n      if (!platformApiConfig) {\n        throw new Error(`Platform API configuration not found for ${platformId}`);\n      }\n\n      // Get model config directly from the platform's API config\n      const modelConfig = platformApiConfig?.models?.find(model => model.id === modelId);\n      if (!modelConfig) {\n        throw new Error(`Model configuration not found for ${modelId}`);\n      }\n\n      // Get user settings for this model using the provided modelId\n      const userSettings = await this.getUserModelSettings(platformId, modelId);\n\n      // Determine effective toggle values, defaulting to true if not set\n      const effectiveIncludeTemperature = userSettings.includeTemperature ?? true;\n      const effectiveIncludeTopP = userSettings.includeTopP ?? false; // TopP default to false\n\n      // Start with base parameters\n      const params = {\n        model: modelId,\n        parameterStyle: modelConfig.parameterStyle,\n        tokenParameter: modelConfig.tokenParameter,\n        maxTokens: userSettings.maxTokens !== undefined ? userSettings.maxTokens : (modelConfig.maxTokens),\n        contextWindow: modelConfig.contextWindow,\n        modelSupportsSystemPrompt: modelConfig?.supportsSystemPrompt ?? false,\n      };\n\n      // Add temperature ONLY if model supports it AND user included it\n      const modelSupportsTemperature = modelConfig?.supportsTemperature !== false;\n      if (modelSupportsTemperature && effectiveIncludeTemperature) {\n        params.temperature = userSettings.temperature !== undefined\n          ? userSettings.temperature\n          : platformApiConfig.temperature;\n      }\n\n      // Add topP ONLY if model supports it AND user included it\n      const modelSupportsTopP = modelConfig?.supportsTopP === true;\n      if (modelSupportsTopP && effectiveIncludeTopP) {\n        params.topP = userSettings.topP !== undefined\n          ? userSettings.topP\n          : platformApiConfig.topP;\n      }\n\n      // Calculate effective system prompt support\n      const platformSupportsSystemPrompt = platformApiConfig?.hasSystemPrompt !== false;\n      const modelExplicitlyForbidsSystemPrompt = modelConfig?.supportsSystemPrompt === false;\n      const effectiveModelSupportsSystemPrompt = platformSupportsSystemPrompt && !modelExplicitlyForbidsSystemPrompt;\n\n      // Update modelSupportsSystemPrompt with the calculated value\n      params.modelSupportsSystemPrompt = effectiveModelSupportsSystemPrompt;\n\n      // Add system prompt ONLY if effectively supported AND user provided one\n      if (params.modelSupportsSystemPrompt && userSettings.systemPrompt) {\n          params.systemPrompt = userSettings.systemPrompt;\n          logger.info(`Adding system prompt for ${platformId}/${modelId}.`);\n      } else if (userSettings.systemPrompt) {\n          if (!platformSupportsSystemPrompt) {\n              logger.warn(`System prompt provided but platform ${platformId} does not support it.`);\n          } else if (modelExplicitlyForbidsSystemPrompt) {\n              logger.warn(`System prompt provided but model ${modelId} explicitly forbids it.`);\n          } else {\n               logger.warn(`System prompt provided but effective support is false for ${platformId}/${modelId}.`);\n          }\n      }\n\n      // Add conversation history if provided in options\n      if (conversationHistory && Array.isArray(conversationHistory) && conversationHistory.length > 0) {\n        params.conversationHistory = conversationHistory;\n      }\n\n      // Include tabId if provided (useful for downstream token tracking)\n      if (tabId) {\n          params.tabId = tabId;\n      }\n\n      logger.info(`FINAL Resolved parameters for ${platformId}/${modelId}:`, { ...params });\n      return params;\n\n    } catch (error) {\n      logger.error(`Error resolving parameters for ${platformId}/${modelId}:`, error);\n      throw error;\n    }\n  }\n}\n\nmodule.exports = new ModelParameterService();\n","const logger = require('../shared/logger.js').service;\nconst { STORAGE_KEYS } = require('../shared/constants');\n\n/**\n * Service for managing tab-specific sidebar state\n */\nclass SidebarStateManager {\n  \n  /**\n   * Toggle sidebar visibility for a specific tab\n   * @private\n   * @param {number} tabId - Tab ID\n   * @param {boolean|undefined} visible - Visibility state (undefined to toggle)\n   */\n  async _toggleForTab(tabId, visible) {\n    // Get current tab states\n    const { [STORAGE_KEYS.TAB_SIDEBAR_STATES]: tabStates = {} } = \n      await chrome.storage.local.get(STORAGE_KEYS.TAB_SIDEBAR_STATES);\n    \n    // Convert tabId to string for use as object key\n    const tabIdStr = tabId.toString();\n    \n    // Determine new visibility\n    if (visible === undefined) {\n      // Toggle current state\n      visible = !(tabStates[tabIdStr] === true);\n    }\n    \n    // Update tab state\n    const updatedStates = {\n      ...tabStates,\n      [tabIdStr]: visible\n    };\n    \n    // Save updated states\n    await chrome.storage.local.set({ \n      [STORAGE_KEYS.TAB_SIDEBAR_STATES]: updatedStates \n    });\n    \n    logger.info(`Tab ${tabId} sidebar visibility set to ${visible}`);\n  }\n  \n  /**\n  /**\n   * Get sidebar state for a specific tab\n   * @private\n   * @param {number} tabId - Tab ID\n   * @returns {Promise<Object>} Tab-specific sidebar state\n   */\n  async _getStateForTab(tabId) {\n    const result = await chrome.storage.local.get([\n      STORAGE_KEYS.TAB_SIDEBAR_STATES,\n      STORAGE_KEYS.SIDEBAR_PLATFORM,\n      STORAGE_KEYS.SIDEBAR_MODEL\n    ]);\n    \n    const tabStates = result[STORAGE_KEYS.TAB_SIDEBAR_STATES] || {};\n    \n    return {\n      visible: tabStates[tabId.toString()] === true,\n      platform: result[STORAGE_KEYS.SIDEBAR_PLATFORM] || null,\n      model: result[STORAGE_KEYS.SIDEBAR_MODEL] || null\n    };\n  }\n  \n  /**\n   * Get current sidebar state for specific tab\n   * @param {number} tabId - Tab ID\n   * @returns {Promise<Object>} Tab-specific sidebar state\n   */\n  async getSidebarState(tabId) {\n    try {\n      if (!tabId) {\n        // Get active tab if no tab ID specified\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        const activeTab = tabs[0];\n        \n        if (!activeTab || !activeTab.id) {\n          logger.warn('No active tab found for getSidebarState');\n          return {\n            visible: false,\n            platform: null,\n            model: null\n          };\n        }\n        \n        return this._getStateForTab(activeTab.id);\n      }\n      \n      return this._getStateForTab(tabId);\n    } catch (error) {\n      logger.error(`Error getting sidebar state for tab ${tabId}:`, error);\n      return {\n        visible: false,\n        platform: null,\n        model: null\n      };\n    }\n  }\n  \n  /**\n   * Get sidebar visibility for specific tab\n   * @param {number} tabId - Tab ID\n   * @returns {Promise<boolean>} Visibility state\n   */\n  async getSidebarVisibilityForTab(tabId) {\n    try {\n      const { [STORAGE_KEYS.TAB_SIDEBAR_STATES]: tabStates = {} } = \n        await chrome.storage.local.get(STORAGE_KEYS.TAB_SIDEBAR_STATES);\n      \n      return tabStates[tabId.toString()] === true;\n    } catch (error) {\n      logger.error(`Error getting sidebar visibility for tab ${tabId}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Set sidebar visibility for specific tab\n   * @param {number} tabId - Tab ID\n   * @param {boolean} visible - Visibility state\n   * @returns {Promise<boolean>} Success indicator\n   */\n  async setSidebarVisibilityForTab(tabId, visible) {\n    try {\n      await this._toggleForTab(tabId, visible);\n      return true;\n    } catch (error) {\n      logger.error(`Error setting sidebar visibility for tab ${tabId}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Clean up tab states for closed tabs\n   * Called periodically to prevent storage bloat\n   * @returns {Promise<void>}\n   */\n  async cleanupTabStates() {\n    try {\n      // Get all current tabs\n      const tabs = await chrome.tabs.query({});\n      const activeTabIds = new Set(tabs.map(tab => tab.id.toString()));\n      \n      // Get current tab states\n      const { [STORAGE_KEYS.TAB_SIDEBAR_STATES]: tabStates = {} } = \n        await chrome.storage.local.get(STORAGE_KEYS.TAB_SIDEBAR_STATES);\n      \n      // Filter out closed tabs\n      const updatedStates = {};\n      let stateChanged = false;\n      \n      Object.entries(tabStates).forEach(([tabId, state]) => {\n        if (activeTabIds.has(tabId)) {\n          updatedStates[tabId] = state;\n        } else {\n          stateChanged = true;\n          logger.info(`Removing sidebar state for closed tab ${tabId}`);\n        }\n      });\n      \n      // Save updated states if changed\n      if (stateChanged) {\n        await chrome.storage.local.set({ \n          [STORAGE_KEYS.TAB_SIDEBAR_STATES]: updatedStates \n        });\n        logger.info('Tab sidebar states cleaned up');\n      }\n    } catch (error) {\n      logger.error('Error cleaning up tab sidebar states:', error);\n    }\n  }\n}\n\nmodule.exports = new SidebarStateManager();\n","// src/shared/constants.js\n\n/**\n * Content types used throughout the extension\n */\nexport const CONTENT_TYPES = {\n  GENERAL: 'general',\n  REDDIT: 'reddit',\n  YOUTUBE: 'youtube',\n  PDF: 'pdf'\n};\n\n/**\n * Shared prompt type - accessible across all content types\n */\nexport const SHARED_TYPE = 'shared';\n\n/**\n * User-friendly labels for content types\n */\nexport const CONTENT_TYPE_LABELS = {\n  [CONTENT_TYPES.GENERAL]: 'Web Content',\n  [CONTENT_TYPES.REDDIT]: 'Reddit Post',\n  [CONTENT_TYPES.YOUTUBE]: 'YouTube Video',\n  [CONTENT_TYPES.PDF]: 'PDF Document',\n  [SHARED_TYPE]: 'Shared Prompts'\n};\n\n/**\n * AI platforms supported by the extension\n */\nexport const AI_PLATFORMS = {\n  CLAUDE: 'claude',\n  CHATGPT: 'chatgpt',\n  DEEPSEEK: 'deepseek',\n  MISTRAL: 'mistral',\n  GEMINI: 'gemini',\n  GROK: 'grok'\n};\n\n/**\n * Storage keys used throughout the extension\n */\nexport const STORAGE_KEYS = {\n  // Content\n  CONTENT_READY: 'contentReady',\n  EXTRACTED_CONTENT: 'extractedContent',\n  SCRIPT_INJECTED: 'scriptInjected',\n  TAB_FORMATTED_CONTENT: 'tab_formatted_content',\n  FORMATTED_CONTENT_FOR_INJECTION: 'formatted_content_for_injection',\n\n  // Service\n  THEME_PREFERENCE: 'theme_preference',\n  TEXT_SIZE_PREFERENCE: 'text_size_preference',\n  API_ADVANCED_SETTINGS: 'api_advanced_settings',\n  API_CREDENTIALS: 'api_credentials',\n\n  // Prompt\n  PRE_PROMPT: 'prePrompt',\n  CUSTOM_PROMPTS: 'custom_prompts_by_type',\n  DEFAULT_PROMPTS_INIT_FLAG: 'default_prompts_initialized_v1',\n\n  // Platform\n  INJECTION_PLATFORM: 'injectionPlatform',\n  INJECTION_PLATFORM_TAB_ID: 'injectionPlatformTabId',\n  POPUP_PLATFORM: 'popup_platform',\n  SIDEBAR_PLATFORM: 'sidebar_platform_preference',\n  SIDEBAR_MODEL: 'sidebar_model_preferences',\n  TAB_PLATFORM_PREFERENCES: 'tab_platform_preferences',\n  TAB_MODEL_PREFERENCES: 'tab_model_preferences',\n  TAB_SIDEBAR_STATES: 'tab_sidebar_states',\n  \n  // API\n  API_PROCESSING_STATUS: 'apiProcessingStatus',\n  API_RESPONSE: 'apiResponse',\n  API_PROCESSING_ERROR: 'apiProcessingError',\n  API_RESPONSE_TIMESTAMP: 'apiResponseTimestamp',\n  STREAM_ID: 'streamId',\n  \n  // Sidebar\n  TAB_CHAT_HISTORIES: 'tab_chat_histories',\n  TAB_SYSTEM_PROMPTS: 'tab_system_prompts',\n  TAB_TOKEN_STATISTICS: 'tab_token_statistics',\n};\n\n/**\n * Interface sources for API requests\n */\nexport const INTERFACE_SOURCES = {\n  POPUP: 'popup',\n  SIDEBAR: 'sidebar'\n};\n\n/**\n * Prompt types\n */\nexport const PROMPT_TYPES = {\n  CUSTOM: 'custom',\n  QUICK: 'quick'\n};\n\n/**\n * Sidepanel message types\n */\nexport const MESSAGE_ROLES = {\n  USER: 'user',\n  ASSISTANT: 'assistant',\n  SYSTEM: 'system'\n}","// src/shared/logger.js\n\n/**\n * Cross-context logging utility for Chrome extensions\n * Console-only implementation with backward compatibility\n */\n\n// Determine if running in production mode (set by Webpack's mode option)\nconst isProduction = process.env.NODE_ENV === 'production';\n\n/**\n * Log a message to console, conditionally skipping 'info' logs in production.\n * @param {string} context - The context (background, content, popup, etc.)\n * @param {string} level - Log level (info, warn, error)\n * @param {string} message - The message to log\n * @param {any} [data=null] - Optional data to include\n */\nfunction log(context, level, message, data = null) {\n  // --- Production Log Filtering ---\n  // Skip 'info' level logs when in production mode\n  if (isProduction && level === 'info') {\n    return; // Exit early, do not log\n  }\n  // -----------------------------\n\n  // Map level to console method\n  const consoleMethod = level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log'; // Default to 'log' for 'info'\n\n  // Format prefix with context\n  const prefix = `[${context}]`;\n\n  // Log to console with or without data\n  if (data !== null) {\n    console[consoleMethod](prefix, message, data);\n  } else {\n    console[consoleMethod](prefix, message);\n  }\n}\n\n/**\n * Stub function for backward compatibility\n * Returns empty array since we're not storing logs\n * @returns {Promise<Array>} Empty array\n */\nasync function getLogs() {\n  // Log this message even in production, as it's informational about the logger itself\n  console.log('[Logger] getLogs called - logs are not being stored in this version');\n  return [];\n}\n\n/**\n * Stub function for backward compatibility\n */\nasync function clearLogs() {\n  // Log this message even in production\n  console.log('[Logger] clearLogs called - logs are not being stored in this version');\n}\n\nconst logger = {\n  api: {\n    debug: (message, data) => log('api', 'debug', message, data),\n    info: (message, data) => log('api', 'info', message, data),\n    warn: (message, data) => log('api', 'warn', message, data),\n    error: (message, data) => log('api', 'error', message, data)\n  },\n  background: {\n    debug: (message, data) => log('background', 'debug', message, data),\n    info: (message, data) => log('background', 'info', message, data),\n    warn: (message, data) => log('background', 'warn', message, data),\n    error: (message, data) => log('background', 'error', message, data)\n  },\n  content: {\n    debug: (message, data) => log('content', 'debug', message, data),\n    info: (message, data) => log('content', 'info', message, data),\n    warn: (message, data) => log('content', 'warn', message, data),\n    error: (message, data) => log('content', 'error', message, data)\n  },\n  extractor: {\n    debug: (message, data) => log('extractor', 'debug', message, data),\n    info: (message, data) => log('extractor', 'info', message, data),\n    warn: (message, data) => log('extractor', 'warn', message, data),\n    error: (message, data) => log('extractor', 'error', message, data)\n  },\n  popup: {\n    debug: (message, data) => log('popup', 'debug', message, data),\n    info: (message, data) => log('popup', 'info', message, data),\n    warn: (message, data) => log('popup', 'warn', message, data),\n    error: (message, data) => log('popup', 'error', message, data)\n  },\n  platform: {\n    debug: (message, data) => log('platform', 'debug', message, data),\n    info: (message, data) => log('platform', 'info', message, data),\n    warn: (message, data) => log('platform', 'warn', message, data),\n    error: (message, data) => log('platform', 'error', message, data)\n  },\n  message:{\n    debug: (message, data) => log('message', 'debug', message, data),\n    info: (message, data) => log('message', 'info', message, data),\n    warn: (message, data) => log('message', 'warn', message, data),\n    error: (message, data) => log('message', 'error', message, data)\n  },\n  service: {\n    debug: (message, data) => log('service', 'debug', message, data),\n    info: (message, data) => log('service', 'info', message, data),\n    warn: (message, data) => log('service', 'warn', message, data),\n    error: (message, data) => log('service', 'error', message, data)\n  },\n  sidebar: {\n    debug: (message, data) => log('sidebar', 'debug', message, data),\n    info: (message, data) => log('sidebar', 'info', message, data),\n    warn: (message, data) => log('sidebar', 'warn', message, data),\n    error: (message, data) => log('sidebar', 'error', message, data)\n  },\n  getLogs,\n  clearLogs\n};\n\nmodule.exports = logger;","// src/shared/utils/content-utils.js\nimport { CONTENT_TYPES } from '../constants.js';\n\n/**\n * Determine content type based on URL and selection state\n * This is the single source of truth for content type detection\n * \n * @param {string} url - The URL to check\n * @returns {string} - The detected content type\n */\nexport function determineContentType(url) {\n  // PDF detection criteria evaluation\n  const isPdf = url.endsWith('.pdf');\n  const containsPdfPath = url.includes('/pdf/');\n  const containsPdfViewer = url.includes('pdfviewer');\n  const isChromeExtensionPdf = url.includes('chrome-extension://') && url.includes('pdfviewer');\n\n  // PDF detection logic\n  if (isPdf || containsPdfPath || containsPdfViewer || isChromeExtensionPdf) {\n    return CONTENT_TYPES.PDF;\n  } else if (url.includes('youtube.com/watch')) {\n    return CONTENT_TYPES.YOUTUBE;\n  } else if (url.includes('reddit.com/r/') && url.includes('/comments/')) {\n    return CONTENT_TYPES.REDDIT;\n  } else {\n    return CONTENT_TYPES.GENERAL;\n  }\n}\n\nexport function isInjectablePage(url) {\n  if (!url) return false;\n  try {\n    if (url.startsWith('chrome://') || url.startsWith('about:') || url.startsWith('edge://') || url.startsWith('moz-extension://')) {\n      return false;\n    }\n    if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('file://')) {\n      return true;\n    }\n    const parsedUrl = new URL(url);\n    return ['http:', 'https:', 'file:'].includes(parsedUrl.protocol);\n  } catch (e) {\n    console.warn(`URL parsing failed or non-standard scheme for injection check: ${url}`, e.message);\n    return false;\n  }\n}\n","/**\n * Extracts a user-friendly error message from an API response object.\n * Attempts to parse the JSON body and find specific error details.\n * Falls back to a default message based on status code and text.\n *\n * @param {Response} response - The Fetch API Response object.\n * @returns {Promise<string>} A promise that resolves to the formatted error message string.\n */\nexport async function extractApiErrorMessage(response) {\n  let errorData = null;\n  let detailString = null;\n  const defaultMessage = `API error (${response.status}): ${response.statusText || 'Unknown error'}`;\n\n  try {\n    // Clone the response before reading the body, as it can only be read once\n    const clonedResponse = response.clone();\n    errorData = await clonedResponse.json();\n  } catch (jsonError) {\n    // Ignore JSON parsing errors, we'll use the default message\n    console.warn('Failed to parse API error response as JSON:', jsonError);\n    return defaultMessage;\n  }\n\n  // Check for array structure first (e.g., some Gemini errors)\n  if (Array.isArray(errorData) && errorData.length > 0) {\n    const firstError = errorData[0];\n    if (firstError?.error?.message && typeof firstError.error.message === 'string') {\n      detailString = firstError.error.message;\n    }\n  }\n\n  // If not found in array or errorData is not an array, check object structure\n  if (!detailString && errorData && typeof errorData === 'object') {\n    // 1. Check errorData.message\n    if (typeof errorData.message === 'string') {\n      detailString = errorData.message;\n    } else if (typeof errorData.message === 'object' && errorData.message !== null) {\n      // Handle nested message objects (e.g., Mistral's { message: { detail: '...' } })\n      if (typeof errorData.message.detail === 'string') {\n        detailString = errorData.message.detail;\n      } else if (typeof errorData.message.error === 'string') {\n        detailString = errorData.message.error;\n      } else {\n        // Fallback for unexpected object structure in message\n        detailString = JSON.stringify(errorData.message);\n      }\n    }\n\n    // 2. Check errorData.error.message (if message wasn't useful)\n    if (!detailString && errorData.error && typeof errorData.error === 'object' && typeof errorData.error.message === 'string') {\n      detailString = errorData.error.message;\n    }\n    // Check if errorData.error is the string itself\n    else if (!detailString && errorData.error && typeof errorData.error === 'string') {\n      detailString = errorData.error;\n    }\n\n    // 3. Check errorData.detail (string)\n    if (!detailString && typeof errorData.detail === 'string') {\n      detailString = errorData.detail;\n    }\n  }\n\n  // If we found a specific detail, clean it and format the message\n  if (detailString) {\n    // Clean up common prefixes like '* '\n    if (detailString) { detailString = detailString.replace(/^\\*\\s*/, ''); }\n    return `API error (${response.status}): ${detailString}`;\n  } else {\n    // If we couldn't extract a specific string, log for debugging\n    // but return the default message to avoid large objects in UI.\n    const dataType = Array.isArray(errorData) ? 'array' : (typeof errorData);\n    console.warn(`API error data received (type: ${dataType}), but no specific message field found:`, errorData);\n    return defaultMessage;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// src/background/index.js - Entry point for background service worker\n\nimport { initializeExtension } from './initialization.js';\nimport { setupMessageRouter } from './core/message-router.js';\nimport { setupTabListener } from './listeners/tab-listener.js';\n// Import the specific cleanup function and the listener setup\nimport { setupTabStateListener, performStaleTabCleanup } from './listeners/tab-state-listener.js';\nimport SidebarStateManager from '../services/SidebarStateManager.js';\nimport logger from '../shared/logger.js';\n\n/**\n * Main entry point for the background service worker\n */\nasync function startBackgroundService() {\n  try {\n    logger.background.info('Starting background service...');\n    // 1. Initialize extension configuration and state\n    await initializeExtension();\n\n    // 2. Set up message router to handle communication\n    setupMessageRouter();\n\n    // 3. Set up event listeners\n    setupTabListener();\n    setupTabStateListener(); // Sets up onRemoved listener\n    setupConnectionListener(); // Add connection listener setup\n\n    // This runs every time the service worker starts (initial load, wake-up, after browser start)\n    // It complements the onStartup listener.\n    logger.background.info('Running stale tab cleanup on service worker start...');\n    try {\n      await performStaleTabCleanup(); // Call the cleanup function\n      logger.background.info('Service worker start stale tab cleanup completed.');\n    } catch (cleanupError) {\n      logger.background.error('Error during service worker start stale tab cleanup:', cleanupError);\n    }\n\n    // 4. Add the onStartup listener for cleanup (Keep this!)\n    // This listener persists across service worker restarts.\n    chrome.runtime.onStartup.addListener(async () => {\n      logger.background.info('Browser startup detected via onStartup listener. Running stale tab cleanup...');\n      try {\n        // Call the cleanup function directly\n        await performStaleTabCleanup();\n        logger.background.info('Startup stale tab cleanup completed.');\n      } catch (cleanupError) {\n        logger.background.error('Error during startup stale tab cleanup:', cleanupError);\n      }\n    });\n    logger.background.info('onStartup listener registered for cleanup.');\n\n    logger.background.info('Service worker started successfully and listeners are set up.');\n  } catch (error) {\n    logger.background.error('Error starting background service:', error);\n  }\n}\n\n/**\n * Sets up the listener for runtime connections (e.g., from side panel).\n */\nfunction setupConnectionListener() {\n  // This listener also persists across service worker restarts.\n  chrome.runtime.onConnect.addListener((port) => {\n    logger.background.info(`Connection received: ${port.name}`);\n\n    if (port.name.startsWith('sidepanel-connect-')) {\n      const parts = port.name.split('-');\n      const tabIdStr = parts[parts.length - 1];\n      const tabId = parseInt(tabIdStr, 10);\n\n      if (!isNaN(tabId)) {\n        logger.background.info(`Side panel connected for tab ${tabId}`);\n\n        // Mark sidebar as visible upon connection\n        SidebarStateManager.setSidebarVisibilityForTab(tabId, true)\n          .then(() => {\n            logger.background.info(`Set sidebar visibility to true for tab ${tabId}`);\n          })\n          .catch(error => {\n            logger.background.error(`Error setting sidebar visibility to true for tab ${tabId}:`, error);\n          });\n\n        // Handle disconnection\n        port.onDisconnect.addListener(() => {\n          logger.background.info(`Side panel disconnected for tab ${tabId}`);\n          if (chrome.runtime.lastError) {\n            // Log error but don't crash the extension\n            logger.background.error(`Port disconnect error for tab ${tabId}: ${chrome.runtime.lastError.message}`);\n          }\n          // Mark sidebar as not visible upon disconnection\n          SidebarStateManager.setSidebarVisibilityForTab(tabId, false)\n            .then(() => {\n              logger.background.info(`Set sidebar visibility to false for tab ${tabId}`);\n            })\n            .catch(error => {\n              logger.background.error(`Error setting sidebar visibility to false for tab ${tabId}:`, error);\n            });\n        });\n\n      } else {\n        logger.background.error(`Could not parse tabId from port name: ${port.name}`);\n      }\n    } else {\n      logger.background.info(`Ignoring connection from non-sidepanel source: ${port.name}`);\n    }\n  });\n  logger.background.info('Runtime connection listener set up.');\n}\n\n// Start the background service when the file is loaded\n// This runs every time the service worker starts (initial load, wake-up)\nstartBackgroundService();"],"names":["ApiInterface","require","extractApiErrorMessage","ConfigService","logger","api","BaseApiService","constructor","platformId","credentials","config","initialize","getPlatformApiConfig","info","processRequest","requestConfig","prompt","resolvedParams","formattedContent","onChunk","abortSignal","apiKey","model","Error","structuredPrompt","_createStructuredPrompt","fetchOptions","_buildApiRequest","_executeStreamingRequest","success","error","done","message","trim","length","validateCredentials","warn","isValid","_validateApiKey","defaultModel","_validateWithModel","_buildValidationRequest","response","fetch","url","method","headers","body","ok","status","errorMessage","params","_parseStreamChunk","line","_resetStreamState","_handleParsedChunk","parsedResult","accumulatedContent","type","Array","isArray","chunks","subChunk","chunk","reader","decoder","TextDecoder","buffer","signal","getReader","value","read","parseError","fullContent","decodedChunk","decode","stream","lineEnd","indexOf","substring","name","cancel","cancelError","module","exports","ChatGptApiService","ClaudeApiService","GeminiApiService","MistralApiService","DeepSeekApiService","GrokApiService","ApiFactory","createApiService","toLowerCase","endpoint","requestPayload","messages","systemPrompt","push","role","content","conversationHistory","_formatOpenAIMessages","parameterStyle","tokenParameter","maxTokens","temperature","top_p","topP","JSON","stringify","startsWith","data","parse","choices","delta","e","history","map","msg","validationPayload","max_tokens","text","system","_formatClaudeMessages","eventType","streamErrorMessage","currentPrompt","formattedMessages","_formatDeepSeekMessages","lastMessage","finish_reason","apiRole","i","_getGeminiEndpoint","baseTemplate","isExperimental","includes","apiVersion","replace","URL","searchParams","append","formattedRequest","_formatGeminiRequestWithHistory","contents","parts","modelSupportsSystemPrompt","systemInstruction","generationConfig","maxOutputTokens","toString","jsonString","textChunk","candidates","finishReason","messageRole","_formatGrokMessages","_formatMistralMessages","ApiServiceManager","ModelParameterService","ContentFormatter","extractContent","determineContentType","isInjectablePage","INTERFACE_SOURCES","STORAGE_KEYS","resetExtractionState","initializeStreamResponse","getExtractedContent","setApiProcessingError","completeStreamResponse","hasFormattedContentForTab","storeFormattedContentForTab","getFormattedContentForTab","storeSystemPromptForTab","activeAbortControllers","Map","handleApiModelRequest","requestType","sendResponse","getPreferredAiPlatform","isAvailable","isApiModeAvailable","models","getAvailableModels","result","chrome","storage","local","get","API_RESPONSE","API_PROCESSING_STATUS","API_RESPONSE_TIMESTAMP","timestamp","streamId","background","controller","abort","delete","abortError","processContentViaApi","tabId","promptId","modelId","source","POPUP","customPrompt","streaming","missing","join","extractedContent","newlyFormattedContent","contentType","skipExtractionRequested","skipInitialExtraction","isFirstUserMessage","initialFormattedContentExists","canInject","shouldExtract","skippedContext","reason","formatContent","promptContent","resolveParameters","Date","now","Math","random","formattedContentForRequest","promptToStoreOrClear","storeError","SIDEBAR","tabs","sendMessage","action","err","createStreamHandler","AbortController","set","apiResponse","processWithUnifiedConfig","processingError","modelToUse","handleChunk","chunkData","runtime","finalChunkData","cancelled","handleCredentialOperation","handleProcessContentRequest","handleProcessContentViaApiRequest","handleToggleNativeSidePanelAction","handleThemeOperation","handleClearTabDataRequest","messageHandlers","setupMessageRouter","registerCoreHandlers","registerApiHandlers","registerServiceHandlers","onMessage","addListener","sender","tab","id","handler","hasSelection","resetState","SCRIPT_INJECTED","INJECTION_PLATFORM_TAB_ID","CONTENT_READY","EXTRACTED_CONTENT","key","String","TAB_SYSTEM_PROMPTS","allTabSystemPrompts","hasOwnProperty","savePlatformTabInfo","formattedContentString","INJECTION_PLATFORM","PRE_PROMPT","FORMATTED_CONTENT_FOR_INJECTION","verifyData","updateScriptInjectionStatus","injected","saveExtractedContent","initialResponse","STREAM_ID","finalResponse","storageUpdate","API_PROCESSING_ERROR","msgError","catchError","fallbackError","TAB_FORMATTED_CONTENT","allFormattedContent","getPlatformTabInfo","scriptInjected","initializeDefaultPrompts","getURL","statusText","defaultPromptsConfig","json","syncResult","sync","CUSTOM_PROMPTS","promptsByType","promptsAdded","Object","call","prompts","defaultPromptsForType","defaultPromptName","defaultPromptContent","existingPrompts","nameExists","values","some","newPromptId","toISOString","newPrompt","createdAt","updatedAt","initializeExtension","query","initialSidebarStates","TAB_SIDEBAR_STATES","handleInstallation","details","flagKey","DEFAULT_PROMPTS_INIT_FLAG","flagResult","promptInitSuccess","onInstalled","isPlatformTab","getPlatformContentScript","injectContentScript","SidebarStateManager","setupTabListener","onUpdated","handleTabUpdate","onActivated","handleTabActivation","onCreated","handleTabCreation","changeInfo","aiPlatformTabId","isPlatform","contentScript","injectionSuccess","hasContent","isVisible","getSidebarVisibilityForTab","newContentType","newUrl","activeInfo","sidePanel","setOptions","path","enabled","newTab","setSidebarVisibilityForTab","TAB_SPECIFIC_DATA_KEYS_TO_CLEAR","TAB_CHAT_HISTORIES","TAB_TOKEN_STATISTICS","TAB_MODEL_PREFERENCES","TAB_PLATFORM_PREFERENCES","ALL_TAB_SPECIFIC_KEYS_FOR_CLEANUP","clearSingleTabData","tabIdStr","storageKey","undefined","then","catch","cleanupTabStorage","validTabIds","storageData","currentData","updatedData","hasChanges","Set","storedTabIdStr","keys","storedTabId","parseInt","isNaN","has","setupTabStateListener","onRemoved","removeInfo","isWindowClosing","cleanupTabStates","performStaleTabCleanup","size","scriptFile","Promise","resolve","storageListener","changes","area","newValue","clearTimeout","timeoutId","onChanged","removeListener","setTimeout","scripting","executeScript","target","files","openAiPlatformWithContent","processContent","useApi","code","extractionResult","effectivePlatformId","CredentialManagerService","operation","storedCredentials","getCredentials","storeResult","storeCredentials","removeResult","removeCredentials","validationResult","verifyApiCredentials","hasCredentials","AI_PLATFORMS","platformDisplayInfo","getPlatformDisplayConfig","platformUrl","platformName","create","CLAUDE","CHATGPT","DEEPSEEK","MISTRAL","GEMINI","GROK","toggleNativeSidePanel","targetTabId","newState","explicitTabId","activeTab","active","currentWindow","currentState","visible","getSidebarState","state","theme","THEME_PREFERENCE","sidebarStateResult","sidebarStates","targetTabIds","entries","CredentialManager","service","credentialManager","modelParameterService","hasStreaming","hasHistory","hasFormattedContent","apiService","credentialsToUse","settings","getApiSettings","apiServiceManager","cachedApiConfig","cachedDisplayConfig","_loadConfig","urlPath","cacheRef","getApiConfig","getDisplayConfig","aiPlatforms","getAllPlatformConfigs","displayConfig","apiConfigData","all","platformList","displayInfo","apiInfo","iconUrl","icon","docApiLink","modelApiLink","consoleApiLink","keyApiLink","apiConfig","filter","p","clearConfigCache","contentData","formatted","_formatYouTubeData","_formatRedditData","_formatGeneralData","_formatPdfData","title","videoTitle","channel","channelName","description","videoDescription","transcript","commentsText","comments","forEach","comment","index","author","likes","videoId","postTitle","postContent","postAuthor","postUrl","subreddit","formattedText","popularity","permalink","pageTitle","pageUrl","pageAuthor","pageDescription","metadataText","pdfTitle","pdfUrl","pageCount","metadata","creationDate","ocrRequired","contentObj","STORAGE_KEY","API_CREDENTIALS","allCredentials","cachedConfig","resolveModel","options","tabPrefs","tabModels","SIDEBAR_MODEL","sourcePrefs","sourcePref","getModelConfig","modelIdOrObject","platformApiConfig","find","getUserModelSettings","API_ADVANCED_SETTINGS","advancedSettings","platformSettings","modelSettings","default","saveTabModelPreference","saveSourceModelPreference","prefs","modelPrefs","modelConfig","userSettings","effectiveIncludeTemperature","includeTemperature","effectiveIncludeTopP","includeTopP","contextWindow","supportsSystemPrompt","modelSupportsTemperature","supportsTemperature","modelSupportsTopP","supportsTopP","platformSupportsSystemPrompt","hasSystemPrompt","modelExplicitlyForbidsSystemPrompt","effectiveModelSupportsSystemPrompt","_toggleForTab","tabStates","updatedStates","_getStateForTab","SIDEBAR_PLATFORM","platform","activeTabIds","stateChanged","CONTENT_TYPES","GENERAL","REDDIT","YOUTUBE","PDF","SHARED_TYPE","CONTENT_TYPE_LABELS","TEXT_SIZE_PREFERENCE","POPUP_PLATFORM","PROMPT_TYPES","CUSTOM","QUICK","MESSAGE_ROLES","USER","ASSISTANT","SYSTEM","isProduction","process","env","NODE_ENV","log","context","level","consoleMethod","prefix","console","getLogs","clearLogs","debug","extractor","popup","sidebar","isPdf","endsWith","containsPdfPath","containsPdfViewer","isChromeExtensionPdf","parsedUrl","protocol","errorData","detailString","defaultMessage","clonedResponse","clone","jsonError","firstError","detail","dataType","startBackgroundService","setupConnectionListener","cleanupError","onStartup","onConnect","port","split","onDisconnect","lastError"],"sourceRoot":""}